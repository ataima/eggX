#!/bin/bash  
#############################################
#
#   EGG BUILD SYSTEM
#
#############################################
#Colors
WHITE=" -e \E[1;37m"
GRAY_LIGHT=" -e \E[0;37m"
GRAY_DARK=" -e \E[1;30m"
BLUE=" -e \E[0;34m"
BLUE_LIGHT=" -e \E[1;34m"
GREEN=" -e \E[0;32m"
GREEN_LIGHT=" -e \E[1;32m"
CYAN=" -e \E[0;36m"
CYAN_LIGHT=" -e \E[1;36m"
RED=" -e \E[0;31m"
RED_LIGHT=" -e \E[1;31m"
PURPLE=" -e \E[0;35m"
PURPLE_LIGHT=" -e \E[1;35m"
BROWN=" -e \E[0;33m"
YELLOW=" -e \E[1;33m"
BLACK=" -e \E[0;30m"
REPLACE=" -e \E[0m"




#PUBLIC FUNCTION EXPORTED TO ALL GENERATED SCRIPTS 
#$1 color
#$2   string
function print_c(){ #EX
echo -e $(echo $1) "$2" $(echo $3) "$4"$(echo $5) "$6" $(echo $REPLACE)
} #EX


# $1..3 argv
function print_s_ita(){ #EX
local A1=$(printf "%-20s" "$1")
local A2=$(printf "%-20s" "$2")
local A3=$(printf "%-20s" "$3")
echo  $(echo $GREEN_LIGHT) "$A1" $(echo $WHITE) "$A2" $(echo $RED_LIGHT) "$A3" $(echo $REPLACE)
} #EX




#none
function print_del_ita(){ #EX
print_s_ita "--------------------" "--------------------" "--------------------"
} #EX

# $1..3 argv
function print_ita(){ #EX
print_del_ita
print_s_ita "$1" "$2" "$3"
} #EX

#$1   string
#$2   string
#$3   string
function error_c(){ #EX
print_del_ita
print_c "$RED_LIGHT" "ERROR : " "$BLUE_LIGHT" " - $1" 
if [ "$2" ]; then
	print_c "$WHITE" "	> " "$YELLOW" "- $2" 
	if [ "$3" ]; then
		print_c "$WHITE" "	> " "$YELLOW" "- $3" 
		if [ "$4" ]; then
			print_c "$WHITE" "	> " "$YELLOW" "- $4" 
			if [ "$5" ]; then
				print_c "$WHITE" "	> " "$YELLOW" "- $5" 
				if [ "$6" ]; then
					print_c "$WHITE" "	> " "$YELLOW" "- $6" 
				fi
			fi	
		fi
	fi
fi
print_c "$GRAY_DARK" "PATH  :" "$GRAY_LIGHT" $(pwd)
print_c "$GRAY_DARK" "FILE  :" "$GRAY_LIGHT" "$0"
print_c "$GRAY_DARK" "LINE  :" "$GRAY_LIGHT" "${BASH_LINENO[0]}"
print_del_ita
#TO DO ITERATIVE 
if [ $ITERATIVE -eq 0 ]; then
	exit 1
fi
} #EX



#$1   string
#$2   string
#$3   string
function warning_c(){ #EX
print_del_ita
print_c "$GREEN_LIGHT" "WARNING : " "$BLUE_LIGHT" "- $1" 
if [ "$2" ]; then
	print_c "$WHITE" "	 >"  "$YELLOW" " - $2" 
	if [ "$3" ]; then
		print_c "$WHITE" "	 >"  "$YELLOW" " - $3" 
		if [ "$4" ]; then
			print_c "$WHITE" "	 >"  "$YELLOW" " - $4" 
			if [ "$5" ]; then
				print_c "$WHITE" "	 >"  "$YELLOW" " - $5" 
				if [ "$6" ]; then
					print_c "$WHITE" "	 >"  "$YELLOW" " - $6" 
				fi
			fi
		fi
	fi
fi
print_del_ita
} #EX



#$1 full filename
function check_exist(){ #EX
if  [ -e "$1" ] && [ -f "$1" ] ; then 
	return 0
fi
return 1
} #EX

#$1 file to execute 
#$2 string to compare
function check_version(){ #EX
if [ $# -ne 2 ]; then 
	error_c "Missing parameter on call check_version" "$1 $(basename "$0")"
fi
local VERSION=`$1 --version `
if [ $? -ne 0 ]; then 
	error_c "Request $1 --version Fail!" "$1 $(basename "$0")"
fi
if [ ! "$(echo $VERSION | grep $2)" ]; then
	error_c "Request $1 : $2 !=$VERSION" "$1 $(basename "$0")"
fi
return 0
} #EX


#$1 projects name  
#$2 step phase
#$3 build value 0 to configure 1 to build 2 is stable ( configured + builded +installed )
function check_build_status(){ #EX
local RES=0
if [ $# -ne 3 ]; then 
	error_c "Missing parameter on call checck_build_status" "$1_$2 $(basename "$0")"
fi
check_exist "$BUILDS/$1_$2/status"
if [ $? -eq 1 ]; then
	error_c "File $BUILDS/$1_$2/status not exist!" "$1_$2 $(basename "$0")"
fi
local ST=$(cat $BUILDS/$1_$2/status)
if [ $ST -ne $3 ]; then
	error_c "Request $1_$2 Status : $3 != $ST " "$1_$2 $(basename "$0")"
fi
return 0
} #EX


#$1 projects name  
#$2 step phase
function check_depend(){ #EX
check_build_status $1 $2 2
} #EX

#$1 file name
function check_file_exist(){ #EX
if [ $# -ne 1 ]; then 
	error_c "Missing parameter on call build_status" " $(basename "$0")"
fi
check_exist $1
if [ $? -ne 0 ]; then 
	error_c "File $1 not exist!" " $(basename "$0")"
fi
return 0
} #EX




# $1  string 
# $2  string
function equs(){
local RES=0
if [ "$1" == "$2" ]; then
	RES=1
fi
return $RES
}

# $1  string 
# $2  string
function noequs(){
local RES=0
if [ "$1" != "$2" ]; then
	RES=1
fi
return $RES
}


# $1  string 
# $2  array string
function range_multi(){
local RES=0
local AA=$(echo $2 | grep $1)
if [ "AA" != "" ]; then
	RES=1
fi
return $RES
}

#global variable for input arg
# collection of input option all string with -xx
OPT_ARGV=""
#all argv not in -
ARGV=""
#number of input in ARGV
ARGN=0
# called with "$@"
function input_arg(){
OPT_ARGV=""
ARGV=""
ARGN=0
local i=""
for i in "$@" ; do
	if [ "${i:0:1}" == "-" ]; then
		OPT_ARGV+=" $i"
	else
		ARGV+=" $i"
		ARGN=$((ARGN+1))
	fi
done
}

#$1 project
#$2 xml node 
#return value
function xml_value(){
 local PRJ=$(xmlstarlet sel -t  -v '/egg/project/name' -n $REPO/$1/conf.egg)
 if [ "$PRJ" == "$1" ];then	
	 local VALUE=$(xmlstarlet sel -t  -v "$2" -n $REPO/$1/conf.egg)
	 
	 #if [  "${VALUE:0:1}" == "$" ]; then 
		 #if a env variable
	#	 local UV=$(echo $VALUE | sed -e 's/\$//g')
	#	 VALUE=$(env | grep $UV | sed -e 's/=/ /g' | awk '{print $2}')
	 #fi
	 echo $VALUE
 else
	error_c "Mistake in project name" "Conf.egg referred to $PRJ : $1"
 fi
}


#$1 project
#$2 xml node
#return num node match
function xml_count(){
declare -i RES=0
local PRJ=$(xmlstarlet sel -t  -v '/egg/project/name' -n $REPO/$1/conf.egg)
 if [ "$PRJ" == "$1" ];then	
RES=$(xmlstarlet sel -t  -v "count($2)" -n $REPO/$1/conf.egg)
fi
return $RES
}

#$1 file 
#$2 xml node
#return num node match
function xml_multi_repo_count(){
declare -i RES=0
RES=$(xmlstarlet sel -t  -v "count($2)" -n $1)
return $RES
}

#$1 file 
#$2 xml node
#return num node match
function xml_multi_repo_value(){
local VALUE=""
VALUE=$(xmlstarlet sel -t  -v "$2" -n $1)
echo $VALUE
}

#$1 file
#$2 node
function getXmlConfValue(){
local RES=xmlstarlet sel -t  -v "egg/conf/$1" -n "$2"
if [ $? -ne 0 ]; then 
		error_c "XML file $MAINFILE" "node $II fail : check valid xml"
fi
echo $RES
}

#$1 project
#$2 xml node
#return num node match
function xml_get_env(){
HW_ARCH=$(uname -m)
local MAINFILE="$REPO/conf.egg"
declare -A XNAME="root  repo sources images store  build editor \
				 path ld_library_path"
local II=""
local VV=""
local NUM=0
local ID=0
#load user defined variable globals
NUM=$(xmlstarlet sel -t  -v "count(egg/conf/user_env)" -n $MAINFILE)
if [ $NUM -ne 0 ]; then 
	ID=0
	USER_ENV=""
	#print_del_ita
	while [ $ID -lt $NUM ]; do
	local VV=$(xmlstarlet sel -t  -v egg/conf/user_env[@id=\"$ID\"]/name -n $MAINFILE)
	local VALUE=$(xmlstarlet sel -t  -v egg/conf/user_env[@id=\"$ID\"]/value -n $MAINFILE)
	if [ "$VV" != "" ] && [ "$VALUE" != "" ]; then
		eval $VV="$VALUE"
		export $VV
		USER_ENV+="  $VV"		
		print_s_ita "Add user env var" "$VV"   "$VALUE"
	else
		error_c "XML file $MAINFILE" "node user_env id=\"$ID\" fail, check xml"
	fi
	ID=$((ID+1))
	done 
fi
#load global variable
for II in $XNAME; do
	local VALUE=$(xmlstarlet sel -t  -v egg/conf/$II -n $MAINFILE)	
	if [ "$VALUE" ]; then
		VV=$(echo $II |   tr '[:lower:]' '[:upper:]')
		eval $VV="$VALUE"
		export $VV
	else
		error_c "XML file $MAINFILE" "node $II fail, check xml"
	fi	
done
}


#$1 param to test
function isNumber(){
local RES='^[0-9]+$'
if ! [[ $1 =~ $RES ]] ; then
	RES=1
else
	RES=0
fi
return $RES
}

#$1 fulle filename
function getFileSize(){ #EX
if  [ -e "$1" ] && [ -f "$1" ] 
then 
	echo   -n $(wc -c < "$1")
	return 1
fi
echo -n 0
return 0
} #EX



#$1   s...S10
function info_simple(){
print_del_ita
print_c "$WHITE" "$@" 
print_del_ita
}

#$1   string
#$2   string
#$3   string
#$4   string
#$5   string
#$6   string
#$7   string
#$8   string
function help_c(){
print_del_ita
print_c "$GREEN_LIGHT" "HELP :" "$BLUE_LIGHT" "$1"
if [ "$2" ]; then
        print_c "$WHITE" "     >"  "$YELLOW" "$2"
        if [ "$3" ]; then
                print_c "$WHITE" "     >"  "$YELLOW" "$3"
                if [ "$4" ]; then
                        print_c "$WHITE" "     >"  "$YELLOW" "$4"
                        if [ "$5" ]; then
                                print_c "$WHITE" "     >"  "$YELLOW" "$5"
                                if [ "$6" ]; then
                                        print_c "$WHITE" "     >"  "$YELLOW" "$6"
                                        if [ "$7" ]; then
						print_c "$WHITE" "     >"  "$YELLOW" "$7"
						if [ "$8" ]; then
							print_c "$WHITE" "     >"  "$YELLOW" "$8"
							if [ "$9" ]; then
								print_c "$WHITE" "     >"  "$YELLOW" "$9"
							fi
						fi
                                        fi
                                fi
                        fi
                fi
        fi
fi
print_del_ita
}

################# START EGG ......


if [ "$OROOT" == "" ] ; then
	OROOT="$HOME/eggX"
fi

OREPO=$OROOT/repo/.

# eggX working path default before read general conf.egg
ROOT="$HOME/ebuild"
REPO="$ROOT/repo"
SOURCES="$ROOT/sources"
IMAGES="$ROOT/images"
REPOBACKUP="$ROOT/backup"
BUILD="$ROOT/build"
EDITOR="vim"
#initial value PATH
MYPATH=""
CPATH=""
C_INCLUDE_PATH=""
CPLUS_INCLUDE_PATH=""
LD_LIBRARY_PATH=""
ARCH=""
CROSS=""
NATIVE=""
CC=""
CXX=""
AS=""
LD=""
NM=""
AR=""
STRIP=""
HW_ARCH=""
CROSS_COMPILE=""
ITERATIVE=0
USER_ENV=""


   
declare -A SORTREQ


declare -i MAX_STEP=0


function forcestop(){
	error_c "User Interrupt" " warning work not complete! "
}

trap "forcestop" SIGHUP SIGINT SIGTERM






# test if exist project <name> from packets list...
# $1 packet name
function check_project(){
local tmp=""
if [[ -n "${MAP[$1]}" ]]; then
	return 1
fi
return 0
}



#$1 build name
#$2 dir
function remove_path(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi	
[ $STEP_STEP -eq 1 ] && trap read debug
local V=$(echo $MYPATH | sed -e 's/:/  /g')
local OLD=$2
MYPATH=""
for I in $V; do
	if [ "$I" != "$OLD" ]; then
		MYPATH="$MYPATH:$I" 
	fi
done
}


#$1 build name
#$2 dir
function add_path(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local NEW=$2
local V=$(echo $MYPATH | sed -e 's/:/  /g')
for I in $V; do
	if [ "$I" == "$NEW" ]; then
		return 
	fi
done
MYPATH="$NEW:"$MYPATH
}

#$1 build name
#$2 dir
function set_path(){
eval MYPATH="$2"
}

#$1 project
#$2 build phase number 0,1,2.....
function insert_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRI=""
local SILENT=""
local INDEX=""
local NUM=0
local ID=0
local TPATH=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					ID=0
					while [  $ID -lt $NUM ]; do
						PRI=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$ID\"]/priority")		
						equs "$PRI"  
						if [ $? -eq 1 ]; then 
							error_c "Missing  build make id=$ID priority Phase $2" "project : $1"
						fi						
						#optional				
						INDEX="$PRI%$1%$STEP_NAME%$ID"
						BSEQ[$INDEX]="$INDEX"
						ID=$((ID+1))
					done	
				fi
			else
				if [ $MOREWRN -ne 0 ]; then
				warning_c "no build step $2  !" "project : $1"
				fi
			fi
		else
			if [ $MOREWRN -ne 0 ]; then
			warning_c "no build  !" "project : $1"
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi

}

#$1 project
#$2 STEP 0,1,2.....
function insert_packet_download(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local NUM=0
local ID=0
local TPATH=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then	
		xml_count $1 "/egg/project/remote"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then			
			#optional		
			INDEX="$2%$1%$STEP_NAME"
			BSEQ[$INDEX]="$INDEX"
			fi
		else
			warning_c "no download  !" "project : $1"
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}



#$1 project
#$2 build phase number 0,1,2.....
function manage_path_pre(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local TPATH=""
local NUM=0
local MAX=0
local ID=0
#set -x ;trap read debug
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then	
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/pre"
				NUM=$?
				if [ $NUM -ne 0 ]; then 				
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/remove"
					NUM=$?
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/add"
					MAX=$?
					if [ $NUM -gt $MAX ]; then
						MAX=$NUM
					fi		
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/set"
					NUM=$?	
					if [ $NUM -gt $MAX ]; then
						MAX=$NUM
					fi					
					ID=0
					while [ $ID -lt $MAX ]; do
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/set")
						if [ "$TPATH" != "" ]; then
							set_path $STEP_NAME "$TPATH"
						fi
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/add[@id=\"$ID\"]")
						if [ "$TPATH" != "" ]; then
							add_path $STEP_NAME "$TPATH"
						fi
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/remove[@id=\"$ID\"]")
						if [ "$TPATH" != "" ]; then
							remove_path $STEP_NAME "$TPATH"
						fi
						ID=$((ID+1))
					done 
				fi				
			fi	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}





#$1 project
#$2 build phase number 0,1,2.....
function manage_path_post(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local TPATH=""
local NUM=0
local MAX=0
local ID=0
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then	
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/post"
				NUM=$?
				if [ $NUM -ne 0 ]; then 	
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/post/remove"
					NUM=$?
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/post/add"
					MAX=$?
					if [ $NUM -gt $MAX ]; then
						MAX=$NUM
					fi					
					ID=0
					while [ $ID -lt $MAX ]; do
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/post/set")
						if [ "$TPATH" != "" ]; then
							set_path $STEP_NAME $TPATH
						fi
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/post/add[@id=\"$ID\"]")
						if [  "$TPATH"  !=  ""  ]; then
							add_path $STEP_NAME $TPATH
						fi
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/post/remove[@id=\"$ID\"]")
						if [  "$TPATH"  !=  ""  ]; then
							remove_path $STEP_NAME $TPATH
						fi
						ID=$((ID+1))
					done 
				fi					
			fi	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}


#$1 project
function getSourcePath(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local RES=""
local VV=""
local NAME=$(echo $1 | tr '[:lower:]' '[:upper:]')
local CSOURCE="$SOURCES/$1"
local TEST="configure configure.ac Makefile Configure"
for VV in $TEST ; do
if [ -e $CSOURCE/$VV ]; then
	RES=$CSOURCE
	break;
fi	
done
if [ "$RES" ==  "" ]; then
	VV=$(ls -d $CSOURCE/*/ | tr '[:lower:]' '[:upper:]' | grep $NAME ) 
	if [ "$VV" ]; then
		CSOURCE=$(ls -d $CSOURCE/*/)
	fi
	for VV in $TEST ; do
		if [ -e $CSOURCE$VV ]; then
			RES=$CSOURCE
			break;
		fi	
	done
	if [ "$RES" == "" ]; then 
		cd $CSOURCE
		# chech unix  to configure
		VV=$(ls -d $CSOURCE/*/ | tr '[:lower:]' '[:upper:]' | grep UNIX ) 
		if [ "$VV" ]; then
			for VV in $TEST ; do
			if [ -e $CSOURCE/unix/$VV ]; then
				RES=$CSOURCE
				break;
			fi	
			if [ -e $CSOURCE/Unix/$VV ]; then
				RES=$CSOURCE
				break;
			fi	
			done	
		fi	
		# chech linux   to configure
		VV=$(ls -d $CSOURCE/*/ | tr '[:lower:]' '[:upper:]' | grep LINUX ) 
		if [ "$VV" ]; then
			for VV in $TEST ; do
			if [ -e $CSOURCE/linux/$VV ]; then
				RES=$CSOURCE
				break;
			fi	
			if [ -e $CSOURCE/Linux/$VV ]; then
				RES=$CSOURCE
				break;
			fi	
			done	
		fi		
	fi
fi
echo $RES
}



#$1 project
#$2 step id
#$3 fileout
#$4 build name
function generate_setenv(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
	local SRC=$(getSourcePath $1)	
	echo "#!/bin/sh" > "$3"
	echo "#unset all except $HOME ..." >> "$3"
	ENV=$(env | sed 's/=.*//' | tr '\n' ' ' | sed -e 's/HOME//g')
	echo "ENV=\"$ENV\"" >> "$3"		
	echo "for i in \$ENV ; do ">> "$3"
	echo " unset \$i" >> "$3"
	echo "done" >> "$3"
	echo "#done unset all" >> "$3"
	echo "#current pwd" >> "$3"	
	echo "export PWD=\$(pwd)" >> "$3"	
	echo "#current step" >> "$3"	
	echo "export STEP=$2" >> "$3"
	echo "#current step name" >> "$3"	
	echo "export STEP_NAME=$4" >> "$3"
	echo "#current info" >> "$3"	
	echo "export INFO=\"$STEP_NAME:$4:$INFO\"" >> "$3"
	echo "#current project" >> "$3"	
	echo "export PROJECT=$1" >> "$3"
	echo "#current project name" >> "$3"
	echo "export PROJ_NAME=$1_$2" >> "$3"
	echo "#current store sources" >> "$3"	
	echo "export STORE=$STORE" >> "$3"
	echo "#current sources for projects" >> "$3"	
	echo "export SOURCES=$SOURCES" >> "$3"
	echo "#current repo for projects" >> "$3"	
	echo "export REPOS=$REPO" >> "$3"
	echo "#current repo for this project" >> "$3"	
	echo "export REPO=$REPO/$1" >> "$3"
	echo "#current build path for projects" >> "$3"	
	echo "export BUILDS=$BUILD/$4">> "$3"
	echo "#current source for this project" >> "$3"	
	echo "export SOURCE=$SRC" >> "$3"
	echo "#current build path for this project" >> "$3"
	echo "export BUILD_PATH=$BUILD/$4/$1_$2" >> "$3"
	echo "#current build path usually 'build' for project" >> "$3"	
	echo "export BUILD=$BUILD/$4/$1_$2/build" >> "$3"
	echo "#file containt the status of build fro this projects : 0,1,2">> "$3"
	echo "export STATUS=$BUILD/$4/$1_$2/status" >> "$3"	
	echo "#current out of all builds for eggx environment">> "$3"
	echo "export IMAGES=$IMAGES" >> "$3"
	echo "#current out this project">> "$3"
	echo "export DEPLOY=$IMAGES/$4" >> "$3"	
	echo "#current Hardware ARCH this machine">> "$3"
	echo "export HW_ARCH=$HW_ARCH">> "$3"
	echo "#current ARCH this project">> "$3"
	echo "export ARCH=$ARCH">> "$3"
	echo "#current target CROSS for this project">> "$3"
	echo "export CROSS=$CROSS">> "$3"
	echo "#current CFLAGS this project">> "$3"
	echo "export CFLAGS=\"$CFLAGS\"" >> "$3"
	echo "#current CPPFLAGS this project">> "$3"
	echo "export CPPFLAGS=\"$CPPFLAGS\"" >> "$3"
	echo "#current CXXFLAGS this project">> "$3"
	echo "export CXXFLAGS=\"$CXXFLAGS\"" >> "$3"
	echo "#current LDFLAGS this project">> "$3"
	echo "export LDFLAGS=\"$LDFLAGS\"" >> "$3"
	echo "#current LIBS this project">> "$3"
	echo "export LIBS=\"$LIBS\"" >> "$3"
	echo "#current CPPFLAGS this project">> "$3"
	echo "export CPATH=\"$CPATH\"" >> "$3"
	echo "#current C_INCLUDE_PATH this project">> "$3"
	echo "export C_INCLUDE_PATH=\"$C_INCLUDE_PATH\"" >> "$3"
	echo "#current CPLUS_INCLUDE_PATH this project">> "$3"
	echo "export CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH\"" >> "$3"
	echo "#current LD_LIBRARY_PATH this project">> "$3"
	echo "export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\"" >> "$3"
	echo "#current CC this project">> "$3"
	echo "export CC=$CC" >> "$3"
	echo "#current CXX this project">> "$3"
	echo "export CXX=$CXX" >> "$3"
	echo "#current AS this project">> "$3"
	echo "export AS=$AS" >> "$3"
	echo "#current LD this project">> "$3"
	echo "export LD=$LD" >> "$3"
	echo "#current NM this project">> "$3"
	echo "export NM=$NM" >> "$3"
	echo "#current AR this project">> "$3"
	echo "export AR=$AR" >> "$3"
	echo "#current STRIP this project">> "$3"
	echo "export STRIP=$STRIP" >> "$3"
	echo "#current PATH this project">> "$3"
	echo "export PATH=$MYPATH" >> "$3"		
	echo "#current platform " >> "$3"	
	echo "export NATIVE=$NATIVE" >> "$3"
	echo "#current cross compile  " >> "$3"
	echo "export CROSS_COMPILE=$CROSS_COMPILE" >> "$3"
	local VV=""
	local TT=""
	echo "#user defined env variables  " >> "$3"
	for VV in $USER_ENV; do
		eval TT=\$$VV
		echo "export $VV=$TT" >> "$3"
	done
}




#$1 project
#$2 step
#$3 build path
#$4 value 0,1,2,
function setbuildstatus(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local FILEIN="$3/status"
case $4 in
	0|1|2)
	if [ -f $FILEIN ]; then 
		chmod +w $FILEIN
	fi	
	echo $4 > $FILEIN
	;;
	*)
	error_c "Unknow state to build : $4" "project : $1"
	;;
esac
}

#$1 project
#$2 step
#$3 build path
# STATUS 0=INIT AFTER DOWNLOAD BEFORE do configure command
# STATUS 1=CONFIGURED After executed configure command
#STATUS  2=STABLE after build phase (make...install ...all stages) 
#on build is available  setbuildstatus 0,1,2 from xml file : ex on last  make/rule idxx/ 
#	<post  id="0">
#		<mode>code</mode>		
#		<value>setbuildstatus 2</value>
#	</post >
function getbuildstatus(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1ex_setbuildstatus
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local RES=0
local FILEIN="$3/status" 
local VV=""
VV=$(getFileSize "$FILEIN")
if [ $VV -eq 0 ]
then 
	#not exist , invalid ?..
	setbuildstatus "$3" 0
	VV="0"
else
	VV=$(cat "$FILEIN")
fi
return $VV
}


function ex_getbuildstatus(){ #EX
local VV=$(cat $STATUS)
return $VV
} #EX


function ex_setbuildstatus(){ #EX
if [ "$PWD" != "" ]; then
	cd "$PWD"
fi
check_exist $STATUS
if [ $? -eq 0 ]; then
   chmod +w $STATUS
fi

case $1 in 
	0|1)
		echo $1 > $STATUS
	;;
	2)
		echo $1 > $STATUS
		chmod 444 $STATUS
	;;
	*)
		error_c "Unknow state to build : $1" "project : $1"
	;;
esac
chmod -w "$STATUS"
} #EX

#$1 file to create rewrite
function prepare_script_head(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local II=""
local FUNCEXP="print_c print_s_ita print_del_ita print_ita \
				error_c warning_c check_exist \
				check_version check_build_status check_depend \
				check_file_exist ex_getbuildstatus ex_setbuildstatus \
				getFileSize ex_input_param "
			
head $0 -n25 >> "$1"	
echo "">> "$1"
echo "">> "$1"
echo "ITERATIVE=0">> "$1"
echo "">> "$1"
echo "">> "$1"

for II in $FUNCEXP; do
	extract_function $II >> "$1"
done	
}


#$1 projects
#$2 Step
#$3 title to echo... TODO togliere
#$4 file to write 
#$5 BUILD NAME
#$6 status to check value else exit :if $6=1000 don't check
#$7 msg in stable mode
function prepare_script_generic(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local VV=0
VV=$6
prepare_script_head "$4"
echo "source $BUILD/$5/$1_$2/setenv.sh">> "$4"
echo "" >> "$4"
echo "ex_input_param \$@">> "$4"
echo "" >> "$4"
if [ $VV -ne 1000 ]
then
	echo "ex_getbuildstatus" >> "$4"
	echo "RES=\$?">> "$4"
	echo "if [ \$RES -eq 2 ]; then " >> "$4"
	echo "	print_ita \"Status\" \"stable\" \"skip $7 \"" >> "$4"
	echo "	exit 0" >> "$4"
	echo "fi" >> "$4"
	if [ $VV -eq 2000 ];  then
	       #configure skip if already configured(1) , ok at init (0) error on stable(2)
		VV=$((VV-2000))
		echo "if [ \$RES -eq 1 ]; then " >> "$4"
		echo "	exit 0" >> "$4"
		echo "fi" >> "$4"
	fi
	echo "if [ \$RES -ne $VV ]; then " >> "$4"
	echo "	error_c \"Build status error: current \$RES - request $6\" \"project : $1\"" >> "$4"
	echo "fi" >> "$4"
	echo "">> "$4"
	echo "">> "$4"
fi

echo "cd \$BUILD" >> "$4"
echo "" >> "$4"
echo "" >> "$4"
}

#$1 function name to extract from egg function to export
function extract_function(){
echo ""
echo ""
cat $0 |  sed -n "/function $1(){ #EX/,/} #EX/p"
echo ""
echo ""
}


function ex_input_param(){ #EX
if [ $# -ne 0 ]; then
case $1 in 
    -D|--debug)
     set -x
     shift
     ;;
    -S|--step)
     set -x
     trap read debug
     shift
     ;;
esac     
fi
} #EX


#$1 projects
#$2 Step
#$3 file to write 
#$4 BUILD NAME
function prepare_script_download(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
prepare_script_head "$3"
echo "#fail count ...">> "$3"
echo "FAIL=0">> "$3"
extract_function  test_sign_file >> "$3"
extract_function  check_pgp >> "$3"
extract_function  check_md5sum >> "$3"
extract_function  check_sha1sum >> "$3"
extract_function  check_sign >> "$3"
extract_function  wget_packet >> "$3"
extract_function ex_apply_patch >> "$3"	
extract_function  git_packet >> "$3"
extract_function  svn_packet>> "$3"
extract_function  file_packet>> "$3"
extract_function  apt_packet>> "$3"
echo "" >> "$3"
echo "ex_input_param \$@">> "$3"
echo "" >> "$3"
echo "cd \$BUILD" >> "$3"
echo "" >> "$3"
echo "" >> "$3"
}


#$1 projects
#$2 Step
#$3 title to echo...
#$4 file to write 
function end_script_generic(){
echo "" >> $4
echo "" >> $4
echo "cd \$PWD" >> "$4"
echo "" >> $4
echo "" >> $4
}



#$1 project
#$2 step id
#$3 file out
#$4 path build
#$5 build name
function add_pre_conf(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
declare -i i=0
local VALUE=""
local MODE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				# rebuild 				
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/code"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/code")
					MODE="CODE"
				else
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/script"
					NUM=$?
					if [ $NUM -ne 0 ]; then
						VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/script")
						MODE="SCRIPTS"
					else
						xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/source"
						NUM=$?
						if [ $NUM -ne 0 ]; then
							VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/source")
							MODE="SOURCE"
						else
						     error_c "Missing pre mode id=$i  Phase $2" "project : $1"  
						fi		
					fi				
				fi
				#end 				
				#VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/value")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  pre conf id=$i value Phase $2" "project : $1"
				fi
				#MODE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/mode")	
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  pre conf id=$i mode Phase $2" "project : $1"
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
				echo "#add pre build custom step $i" >> "$3"
				case $MODE in 
					SCRIPTS)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "$4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					SOURCE)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "source $4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					CODE)
						echo "$VALUE"  >> $3
						echo "if [ \$? -ne 0 ]; then">> $3
						echo " error_c \"Custom command  Fail!\" \"$VALUE\"" >> $3
						echo "fi" >> $3
					;;		
					*)
					error_c "Unknow  pre build id=$i mode:$MODE Phase $2" "project : $1"
					;;
				esac				
				i=$((i+1))
				done 
			else
				echo "# no pre configure script available for prject : $1" >> $3
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
}


#$1 project
#$2 step id
#$3 file out
#$4 path build
#$5 build name
function add_post_conf(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
declare -i i=0
local VALUE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/post"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				# rebuild 				
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/code"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/code")
					MODE="CODE"
				else
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/script"
					NUM=$?
					if [ $NUM -ne 0 ]; then
						VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/script")
						MODE="SCRIPTS"
					else
						xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/source"
						NUM=$?
						if [ $NUM -ne 0 ]; then
							VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/source")
							MODE="SOURCE"
						else
						     error_c "Missing  mode post conf id=$i  Phase $2" "project : $1"  
						fi		
					fi				
				fi
				#end 
				#VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/value")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  post conf id=$i Phase $2" "project : $1"
				fi
				#MODE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/mode")	
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  post conf id=$i mode Phase $2" "project : $1"
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
				case $MODE in 
					SCRIPTS)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "$4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					SOURCE)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "source $4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					CODE)
						echo "$VALUE"  >> $3
						echo "if [ $? -ne 0 ]; then">> $3
						echo " error_c \"Custom command  Fail!\" \"$VALUE\"" >> $3
						echo "fi" >> $3
					;;		
					*)
					error_c "Unknow  post conf id=$i mode Phase $2" "project : $1"
					;;
				esac				
				i=$((i+1))
				done 
			else
				echo "# no post configure script available for prject : $1" >> $3
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
echo " "  >> $3
echo "ex_setbuildstatus 1">>"$3"
echo " "  >> $3
echo " "  >> $3
}

#$1 project
#$2 step id
#$3 file out
#$4 silent
function add_extra_conf(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug
fi
[ $STEP_STEP -eq 1 ] && trap read debug
declare -i i=0
local VALUE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/extra"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				echo " \\" >> $3
				VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/extra[@id=\"$i\"]")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  extra conf id=$i Phase $2" "project : $1"
				fi
				echo -n	"$VALUE "  >> $3
				i=$((i+1))
				done 
			fi
		fi	
		if  [ "$4" == "yes" ]; then 
			echo "  >> $3.log 2>&1" >>  $3		
		fi
		echo " "  >> $3	
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
echo "RES=\$?" >> $3
echo "if [ \$RES -ne 0 ]; then" >> $3
echo "    error_c \"Configure return error: \$RES \" \"project : \$PROJECT step \$STEP\"" >> $3
echo "fi" >> $3 
}






#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread //max
#$7 make index 
#s8 build file
function add_rules_build(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local NUM_R=0
local II=0
xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule"
	NUM_R=$?
	if [ $NUM_R -ne 0 ]; then
		II=0
		while  [  $II -lt $NUM_R  ];  do
			NAME=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$II\"]/name")	
			#NAME can be empty for do make ...
			#equs "$NAME"  
			#if [ $? -eq 1 ]; then 
			#	error_c "Missing  make rule name id=$i Phase $2" "project : $1"
			#fi
			THREAD=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$II\"]/thread")
			if [ "$THREAD" == "" ]; then 
				THREAD="$6"				
			else			
				if  [  $THREAD -gt $6 ] ; then 
					THREAD="$6"
				fi	
			fi						
			add_pre_build "$1" "$2" "$8" "$3" "$4" "$II" "$7"
			add_entry_in_main_build_script "$1" "$3"  "$8" "$5" "$THREAD" "$6" "$NAME"
			add_post_build "$1" "$2" "$8" "$3" "$4" "$II" "$7"
			II=$((II+1))
		done 
	fi
}


#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread //max 
#<make>
#<rule id=0>
#<name>all</name> 
#<pre id=0></pre>    optional
#<post id=0></post> optional
#<tread></thread>    optional
#</rule>
#</make>
#
function generate_build_rules(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
#build
local SH_BUILD=""
declare -i II=0
declare -i UU=0
local NAME
local TREAD
declare -i NUM_R=0
declare -i NUM_M=0
local PRI=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM_R=$?
		if [ $NUM_R -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make"
			NUM_M=$?
			if [ $NUM_M -ne 0 ]; then
				UU=0
				while [  $UU -lt $NUM_M  ]; do
					PRI=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$UU\"]/priority")
					local SH_BUILD="$3/build_$PRI.sh"
					rm -f "$SH_BUILD" 
					touch "$SH_BUILD"
					chmod +rwx "$SH_BUILD"
					prepare_script_generic "$1" "$2" "Start build " "$SH_BUILD" "$4" 1 "build"
					echo "declare -i start_time">> "$SH_BUILD"
					echo "declare -i stop_time">> "$SH_BUILD"
					echo "declare -i total_time">> "$SH_BUILD"
					add_rules_build "$1" "$2" "$3" "$4" "$5" "$6" "$UU" "$SH_BUILD"					
					end_script_generic "$1" "$2" "done  build " "$SH_BUILD"					
					UU=$((UU+1))					
				done	
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> "$SH_BUILD"
echo " "  >> "$SH_BUILD"
echo "ex_setbuildstatus 2">> "$SH_BUILD"
echo " "  >> "$SH_BUILD"
echo " "  >> "$SH_BUILD"
#------------------------------------------------------------------------------------------------------------------
}

#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread

function generate_clean_rule(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local SH_CLEAN="$3/clean.sh"
rm -f "$SH_CLEAN" 
touch "$SH_CLEAN" 
chmod +rwx "$SH_CLEAN" 
# clean 
prepare_script_generic "$1" "$2" "Start clean build " "$SH_CLEAN" "$4" 1000 "clean"
echo "if [ -f \$BUILD/Makefile ]; then " >> "$SH_CLEAN"
if [ "$5" == "yes" ]; then 
	echo "	make -C \$BUILD unistall >> $SH_CLEAN.log 2>&1 " >> "$SH_CLEAN"
else
	echo "	make -C \$BUILD  unistall ">> "$SH_CLEAN"
fi
if [ "$5" == "yes" ]; then 
	echo "	make -C \$BUILD clean >> $SH_CLEAN.log 2>&1 " >> "$SH_CLEAN"
else
	echo "	make -C \$BUILD  clean ">> "$SH_CLEAN"
fi
echo "	if [ \$? -ne 0 ]; then">> "$SH_CLEAN"
echo "    	error_c \"Error on clean \" \"project $1\"" >>"$SH_CLEAN"
echo "	fi"  >> "$SH_CLEAN"
echo "fi" >> "$SH_CLEAN"
echo "" >> "$SH_CLEAN"
echo "" >> "$SH_CLEAN"
end_script_generic "$1" "$2" "done clean build " "$SH_CLEAN"
}







#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread
function generate_distclean_rule(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local SH_DISTCLEAN="$3/distclean.sh"
rm -f "$SH_DISTCLEAN"  
touch "$SH_DISTCLEAN" 
chmod +rwx "$SH_DISTCLEAN" 
#distclean 
prepare_script_generic "$1" "$2" "Start distclean build " "$SH_DISTCLEAN" "$4" 1000
echo "cd \$PWD " >> "$SH_DISTCLEAN"
echo "check_exist \$BUILD_PATH/status">> "$SH_DISTCLEAN"
echo "if [ $? -eq 0 ]; then ">> "$SH_DISTCLEAN"
echo "  chmod +w \$BUILD_PATH/status">> "$SH_DISTCLEAN"
echo "  rm -f \$BUILD_PATH/status">> "$SH_DISTCLEAN"
echo "fi">> "$SH_DISTCLEAN"
if [ "$5" == "yes" ]; then 
	echo "	make -C \$BUILD unistall >> $SH_DISTCLEAN.log 2>&1 " >> "$SH_DISTCLEAN"
else
	echo "	make -C \$BUILD  unistall ">> "$SH_DISTCLEAN"
fi

if [ "$5" == "yes" ]; then 
	echo "	make -C \$BUILD distclean >> $SH_DISTCLEAN.log 2>&1 " >> "$SH_DISTCLEAN"
else
	echo "	make -C \$BUILD  distclean ">> "$SH_DISTCLEAN"
fi
echo "	if [ \$? -ne 0 ]; then">> "$SH_DISTCLEAN"
echo "    	error_c \"Error on distclean \" \"project $1\"" >>"$SH_DISTCLEAN"
echo "	fi"  >> "$SH_DISTCLEAN"
echo "rm -rf \$BUILD/* " >> "$SH_DISTCLEAN"
echo "" >> "$SH_DISTCLEAN"
echo "" >> "$SH_DISTCLEAN"
echo "ex_setbuildstatus 0">> "$SH_DISTCLEAN"
end_script_generic "$1" "$2" "done distclean build " "$SH_DISTCLEAN"
}



#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread
function generate_rebuild_rule(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local NUM_R=0
local NUM_M=0
local UU=0
local PRI=0;
local SH_REBUILD="$3/rebuild.sh"
rm -f  "$SH_REBUILD" 
touch "$SH_REBUILD"
chmod +rwx "$SH_REBUILD"
#rebuild
prepare_script_generic "$1" "$2" "Start Rebuild " "$SH_REBUILD" "$4" 1000
echo "cd \$PWD">> "$SH_REBUILD"
echo "if [ \$? -ne 0 ]; then exit \$?; fi">> "$SH_REBUILD"
echo "$3/distclean.sh" >> "$SH_REBUILD"
echo "if [ \$? -ne 0 ]; then exit \$?; fi">> "$SH_REBUILD"
echo "$3/bootstrap.sh" >> "$SH_REBUILD"
echo "if [ \$? -ne 0 ]; then exit \$?; fi">> "$SH_REBUILD"
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM_R=$?
		if [ $NUM_R -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make"
			NUM_M=$?
			if [ $NUM_M -ne 0 ]; then
				UU=0
				while [  $UU -lt $NUM_M  ]; do
					PRI=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$UU\"]/priority")
					echo "$3/build_$PRI.sh">> "$SH_REBUILD"
					echo "if [ \$? -ne 0 ]; then exit \$?; fi">> "$SH_REBUILD"
					UU=$((UU+1))
				done
			fi
		fi
	fi
fi	
end_script_generic "$1" "$2" "done  rebuild " "$SH_REBUILD"
}
#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread
function add_build_script(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
generate_setenv "$1" "$2" "$3/setenv.sh" "$4" "$5"
generate_clean_rule $@
generate_distclean_rule $@ 
generate_build_rules $@
generate_rebuild_rule $@
}

#$1 project
#$2 step id
#$3 file out
#$4 path build
#$5 build name
#$6 rule index
#$7 make index
function add_pre_build(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
declare -i i=0
local VALUE=""
local MODE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				# rebuild 
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/code"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/code")
					MODE="CODE"
				else
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/script"
					NUM=$?
					if [ $NUM -ne 0 ]; then
						VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/script")
						MODE="SCRIPTS"
					else
						xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/source"
						NUM=$?
						if [ $NUM -ne 0 ]; then
							VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/source")
							MODE="SOURCE"
						else
						     error_c "Missing  mode pre conf id=$i  Phase $2" "project : $1"  
						fi		
					fi				
				fi
				#end				
				#VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/value")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  pre build id=$i value Phase $2" "project : $1"
				fi
				#MODE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/mode")	
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  pre build id=$i mode Phase $2" "project : $1"
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
				echo "#add pre build custom step $i" >> "$3"
				case $MODE in 
					SCRIPTS)>> "$3"
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "$4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> "$3"
					;;		
					SOURCE)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "source $4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> "$3"
					;;		
					CODE)
						echo "$VALUE"  >> "$3"
						echo "if [ \$? -ne 0 ]; then">> $3
						echo " error_c \"Custom command  Fail!\" \"$VALUE\"" >> $3
						echo "fi" >> $3						
					;;		
					*)
					error_c "Unknow  pre build id=$i mode:$MODE Phase $2" "project : $1"
					;;
				esac				
				i=$((i+1))
				done 
			else
				echo "# no pre build script available for prject : $1" >> "$3"
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
}



#$1 project
#$2 step id
#$3 file out
#$4 path build
#$5 build name
#$6 rule index
#$7 make index
function add_post_build(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
declare -i i=0
local VALUE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				# rebuild 
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/code"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/code")
					MODE="CODE"
				else
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/script"
					NUM=$?
					if [ $NUM -ne 0 ]; then
						VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/script")
						MODE="SCRIPTS"
					else
						xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/source"
						NUM=$?
						if [ $NUM -ne 0 ]; then
							VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/source")
							MODE="SOURCE"
						else
						     error_c "Missing mode post conf id=$i  Phase $2" "project : $1"  
						fi		
					fi				
				fi
				#end									
				#VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/value")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  post build id=$i Phase $2" "project : $1"
				fi
				#MODE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/mode")	
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  post build id=$i mode Phase $2" "project : $1"
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
				case $MODE in 
					SCRIPTS)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "$4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					SOURCE)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "source $4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					CODE)
						echo "$VALUE"  >> $3
						echo "if [ $? -ne 0 ]; then">> $3
						echo " error_c \"Custom command  Fail!\" \"$VALUE\"" >> $3
						echo "fi" >> $3
					;;		
					*)
					error_c "Unknow  post build id=$i mode:$MODE Phase $2" "project : $1"
					;;
				esac				
				i=$((i+1))
				done 
			else
				echo "# no post build script available for prject : $1" >> $3
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
}




#$1 project
#$2 build path
#$3 file out
#$4 silent 
#$5 threads
#$6 max thread
#$7 make rule name
function add_entry_in_main_build_script(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
echo "start_time=\$(date +%s)">> "$3"
echo " print_s_ita \"       Make \"  \"$7-$6:$5\"  \"start\"" >> "$3"
if [ "$4" == "yes" ]; then 
	echo "make -C \$BUILD -j$5 $7 > $3.log 2>&1 " >> "$3"
else
	echo "make V=1 -C \$BUILD  -j$5 $7 ">> "$3"
fi
echo "if [ \$? -ne 0 ]; then">> "$3"
echo "    error_c \"Error on build \" \"project : $1\"" >>"$3"
echo "fi"  >> "$3"
echo "stop_time=\$(date +%s)">> "$3" 
echo "total_time=\$((stop_time-start_time))">> "$3" 
echo "print_s_ita \"       ... \"  \"done\"  \"\$total_time sec\" ">> "$3" 
}


#$1 project
#$2 build phase number 0,1,2.....
function create_configure_cmd(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local SILENT=""
local NUM=0
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then					
				SILENT=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/silent")
				#optional
				if [ $SILENT ]; then
					range_multi "$SILENT" "yes no"
					if [ $? -eq 0 ]; then 
						error_c "silent value error $SILENT-yes or no only! Phase $2" "project : $1"
					fi
				else
				#default
				SILENT="yes"
				fi
				THREADS=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/threads")
				#optional
				if [ $THREADS ]; then
					range_multi "$THREADS" "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16"
					if [ $? -eq 0 ]; then 
						error_c "Threads value error $THREADS-0..16 only! Phase $2" "project : $1"
					fi
				else
					#default
					THREADS=1
				fi							
			fi	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
local C_BUILD="$BUILD/$STEP_NAME/$1_$2"
local C_FILE="$C_BUILD/bootstrap.sh"
local DEST="$IMAGES/$STEP_NAME"
local SRC=$(getSourcePath $1)
if [ ! -e "$C_BUILD" ] ; then mkdir -p "$C_BUILD";fi
if [ ! -e "$DEST" ] ; then mkdir -p "$DEST"; fi
rm -f "$C_FILE"
setbuildstatus "$1"  "$2" "$C_BUILD" 0
prepare_script_generic "$1"  "$2" "START CONFIGURE" "$C_FILE" "$STEP_NAME"  2000 "configure"
echo "declare -i start_time">> "$C_FILE"
echo "declare -i stop_time">> "$C_FILE"
echo "declare -i total_time">> "$C_FILE"
echo "start_time=\$(date +%s)">> "$C_FILE"
add_pre_conf "$1" "$2" "$C_FILE" "$C_BUILD"  "$STEP_NAME"
EXTSI=$(echo $SILENT  | tr '[:lower:]' '[:upper:]')
if [ "$EXTSI" != "YES" ]; then
	echo "set -x ">> $C_FILE
fi
if [ -e $SRC/configure ]; then
	rm -rf  "$C_BUILD/build"
	mkdir -p "$C_BUILD/build"
	echo -n "$SRC/configure ">> $C_FILE
	add_extra_conf "$1" "$2" "$C_FILE"  "$SILENT" 
else
	if [ -e $SRC/configure.ac ]; then
		# add <pre> autoconf...
		mkdir -p "$C_BUILD/build"
		echo "pushd $SRC">> $C_FILE
		echo "autoconf">> $C_FILE
		echo "popd">> $C_FILE
		echo -n "$SRC/configure  ">> $C_FILE
		add_extra_conf "$1" "$2" "$C_FILE"  "$SILENT" 
		else
			if [ -e $SRC/Configure ]; then
			#perl
				mkdir -p "$C_BUILD/build"
				echo -n "$SRC/Configure ">> $C_FILE
				add_extra_conf "$1" "$2" "$C_FILE"  "$SILENT" 
			else
				if [ -e $SRC/Makefile ]; then
					rm -rf $C_BUILD/build
					ln -s  "$SRC" "$C_BUILD/build"
					echo  "#no configure is needed .... ">> $C_FILE
			else
				warning_c "Configure / Makefile missing" "Addjust path in the conf.egg"
			fi							
		fi		
	fi	
fi	
##
EXTSI=$(echo $SILENT  | tr '[:lower:]' '[:upper:]')
if [ "$EXTSI" != "YES" ]; then
	echo "set +x ">> $C_FILE
fi
add_post_conf "$1" "$2" "$C_FILE" "$C_BUILD"  "$STEP_NAME"
echo "stop_time=\$(date +%s)">> "$C_FILE" 
echo "total_time=\$((stop_time-start_time))">> "$C_FILE" 
echo "print_s_ita \"       ... \"  \"done\"  \"\$total_time sec\" ">> "$C_FILE" 
end_script_generic  "$1"  "$2" "END CONFIGURE" "$C_FILE"
chmod +x "$C_FILE" 
add_build_script "$1" "$2"  "$C_BUILD"  "$STEP_NAME" "$SILENT" "$THREADS" 
print_ita "STEP : $2 PRI : $3" "$1"  "created done !"
}

#$1 project
#$2 build phase number 0,1,2.....
#$3 make priority
#$4 build name
function create_main_scripts(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local FILES="bootstrap clean distclean build_$3 rebuild setenv"
local RES=0
local VV=""
local FMAIN="$BUILD/$4/step_$2.sh"
RES=$(getFileSize "$FMAIN")
if [ $RES -eq 0 ]; then 
	touch "$FMAIN"
fi
for VV in $FILES; do
	echo "# execute $VV.sh for project $1 in folder $BUILD/$4/$1_$3">>"$FMAIN"
	echo "function $VV""___$1 (){">>"$FMAIN"
	echo "   $BUILD/$4/$1_$3/$VV.sh ">>"$FMAIN"
	echo "}">>"$FMAIN"
	echo "">>"$FMAIN"
	echo "">>"$FMAIN"
done
}

#$1 project
#$2 build phase number 0,1,2.....
#$3 make priority
#$4 build name
function create_main_entry(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local FMAIN="$BUILD/$4/step_$2.sh"
RES=$(getFileSize "$FMAIN")
if [ $RES -ne 0 ]; then 
echo "#END_FUNCTION_STEP">>"$FMAIN"
echo "">>"$FMAIN"
echo "">>"$FMAIN"
echo "#search from argv function to call">>"$FMAIN"
echo "#bootstrap bash 1 call bootstrap_bash_1">>"$FMAIN"
echo "function main (){">>"$FMAIN"
echo "local BUILDS=\"\"">>"$FMAIN"
echo "local VV=\"\"">>"$FMAIN"
echo "local LINE=\"\"">>"$FMAIN"
echo "local PRJ=\"\"">>"$FMAIN"
echo "local SCRIPT=\"\"">>"$FMAIN"
echo "if [ \"\$1\" == \"listall\" ]; then">>"$FMAIN"
echo "   RES=0 ">>"$FMAIN"
echo "	 while IFS='' read -r LINE || [[ -n \"\$LINE\" ]]; do">>"$FMAIN"
echo "   if [ \$RES -eq 0 ]; then">>"$FMAIN"
echo "       VV=\$(echo \$LINE | grep START_FUNCTION_STEP)">>"$FMAIN"
echo "       if [ \"\$VV\" == \"\" ]; then">>"$FMAIN"
echo "          continue ">>"$FMAIN"
echo "       fi ">>"$FMAIN"
echo "       RES=1 ">>"$FMAIN"
echo "   fi ">>"$FMAIN"
echo "   VV=\$(echo \$LINE | grep END_FUNCTION_STEP)">>"$FMAIN"
echo "   if [ \"\$VV\" != \"\" ]; then">>"$FMAIN"
echo "      break ">>"$FMAIN"
echo "   fi ">>"$FMAIN"
echo "   VV=\$(echo \$LINE | grep function)">>"$FMAIN"
echo "   if [ \"\$VV\" != \"\" ]; then < \$0">>"$FMAIN"
echo "   	VV=\$(echo \$VV | sed -e 's/function//g' | sed -e 's/(//g'| sed -e 's/)//g'| sed -e 's/{//g' | sed -e 's/___/  /g')">>"$FMAIN"
echo "   	SCRIPT=\$(echo \$VV | awk '{print \$1}')">>"$FMAIN"
echo "   	PRJ=\$(echo \$VV | awk '{print \$2}')">>"$FMAIN"
echo "		print_c \"\$YELLOW\" \"function : \" \"\$GREEN_LIGHT\" \"\$SCRIPT\" \"\$WHITE\" \"\$PRJ\" ">>"$FMAIN"
echo "   fi ">>"$FMAIN"
echo "   done < \$0">>"$FMAIN"
echo "   exit 0">>"$FMAIN"
echo "fi">>"$FMAIN"
echo "if [ \$# -ne 2 ]; then">>"$FMAIN"
echo "    echo usage : ./step_xx.sh scripts project phase">>"$FMAIN"
echo "    exit 1">>"$FMAIN"
echo "fi">>"$FMAIN"
echo "if [ \"\$1\" == \"build\" ]; then">>"$FMAIN"
echo "    BUILDS=\$(ls $BUILD/$4/$1_$2/build_*.sh)">>"$FMAIN"
echo "    for VV in \$BUILDS; do">>"$FMAIN"
echo "    \$VV">>"$FMAIN"
echo "    if [ \$? -ne 0 ]; then ">>"$FMAIN"
echo "    	exit 1">>"$FMAIN"
echo "    fi">>"$FMAIN"
echo "    done">>"$FMAIN"
echo "else">>"$FMAIN"
echo "	 if [ \"\$1\" == \"setenv\" ]; then">>"$FMAIN"
echo "	    cat $BUILD/$4/$1_$2/\$1.sh">>"$FMAIN"
echo "	 else">>"$FMAIN"
echo "      $BUILD/$4/$1_$2/\$1.sh">>"$FMAIN"
echo "	 fi">>"$FMAIN"
echo "fi">>"$FMAIN"
echo "}">>"$FMAIN"
echo "">>"$FMAIN"
echo "">>"$FMAIN"
echo "# main \$@ : req prj step">>"$FMAIN"
echo "main \$@">>"$FMAIN"
fi

chmod +x "$FMAIN"
}

#$1 project
#$2 dest
#$3 patch
function ex_apply_patch(){ #EX
if [ -d "$3" ] ; then
	local VV=$(ls $3)
	local II=""
	local PWD=$(pwd)
	cd $2
	for II in $VV; do
		patch  -p1 < "$3/$II" 
		if [ $? -ne 0 ]; then
			print_c "$RED_LIGHT" "   - FAIL : On apply patch $II ""$YELLOW""project $1"
			print_c "$RED_LIGHT" "   - Try to revert and skip $II ""$YELLOW""project $1"
			patch   -p1 -R < "$3/$II" 
			if [ $? -ne 0 ]; then
				error_c "On revert patch " "$II ""$YELLOW""project $1"
			else
				print_c "$PURPLE" "Reverted patch $II ""$YELLOW""project $1"
			fi
		else
			print_c "$GREEN_LIGHT" "   - Apply patch $II OK" "$YELLOW" "project $1"
		fi
	done
	cd $PWD
else
	patch -s  --directory="$2"  --input="$3" > /dev/null
	if [ $? -ne 0 ]; then
		rm -rf "$3"
		error_c "On apply patch " "$3 project $1"
	else
		print_c "$GREEN_LIGHT" "   - Apply patch $( basename "$3" ) OK" "$YELLOW" $1
	fi
fi
} #EX


# $1 file out
# $2 source
# $3 patch
#$4 project
function write_apply_patch(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
echo "if [ \$? -eq 99 ]; then" >>  "$1"
echo "	ex_apply_patch $4 $2 $3" >>  "$1"
echo "fi" >>  "$1"
echo "" >>  "$1"
echo "" >>  "$1"
}


# $1 project name
# $2 link
# $3 filename 
# $4 password optional
function svn_packet(){ #EX
local RES=0
local RPWD=""
print_c "$GREEN_LIGHT" "   - Svn update source" "$YELLOW" $1
local PNAME="$2/$3"
if [ "$4" !=  "" ]; then
	RPWD="--non-interactive"
fi
if [ ! -d "$SOURCES/$1" ]; then 
	if [ -e "$STORE/$3.tar.bz2" ]; then
	#exit in store a like packet
		cd "$STORE"
		md5sum  -c "$3.tar.bz2.md5" >  /dev/null 
		if [ $? -eq 0 ]; then 
			tar -xvf "$3.tar.bz2" -C "$SOURCES/$1"  >/dev/null
			if [ $? -ne 0 ]; then 
				error_c "Svn source :cannot restore from tar backup " "   project $1"
			fi 
			cd "$SOURCES/$1"
			svn   update  $RPWD
			if [ $? -ne 0 ]; then 
				error_c "Svn Update error " "   project $1"
			fi 
			RES=1
		fi
		cd "$PWD"
	fi	
	if [  $RES -eq 0 ]; then
		mkdir  -p "$SOURCES/$1"
		svn   -q co $PNAME  $SOURCES/$1 $RPWD
		if [ $? -ne 0 ]; then 
			error_c "Svn Checkout error " "   project $1"
		else
			#create a backup tar on store to work offline and to untar + pull for  future
			if [ -e "$STORE/$3.tar.bz2" ]; then
				chmod 666 "$STORE/$3.tar.bz2"
				chmod 666 "$STORE/$3.tar.bz2.md5"
			fi
			rm -rf "$STORE/$3.tar.bz2"
			rm -rf "$STORE/$3.tar.bz2.md5"	
			cd "$SOURCES"			
			tar -cjvSf "$STORE/$3.tar.bz2"  "$1" >/dev/null
			if [ $? -ne 0 ]; then 
				error_c "Svn source :cannot create tar backup " "   project $1"
			fi 
			cd "$PWD"
			md5sum "$STORE/$3.tar.bz22" > "$STORE/$3.tar.bz2.md5"				
			chmod 444 "$STORE/$3.tar.bz2"
			chmod 444 "$STORE/$3.tar.bz2.md5"
		fi 
	fi		
else
	if [ -d ".svn" ]; then 
		local PWD=$(pwd)
		cd "$SOURCES/$1"
		svn   update  $RPWD
		if [ $? -ne 0 ]; then 
			error_c "Svn Update error " "   project $1"
		fi 
		cd "$PWD"
	else
		svn   -q co $PNAME  $SOURCES/$1  $RPWD
		if [ $? -ne 0 ]; then 
			error_c "Svn Checkout error " "   project $1"
		fi 	
	fi
fi
} #EX

# $1 project name
# $2 link
# $3 filename 
function git_packet(){ #EX
local RES=0
print_c "$GREEN_LIGHT" "   - Git  source" "$YELLOW" $1
local PNAME="$2/$3"
local PWD=$(pwd)
if [ ! -d "$SOURCES/$1" ]; then 
	if [ -e "$STORE/$3.tar.bz2" ]; then
	#exit in store a like packet
		if [ ! -d "$SOURCES" ]; then 
			mkdir -p "$SOURCES"
		fi
		cd "$STORE"
		md5sum  -c "$3.tar.bz2.md5" >  /dev/null 
		if [ $? -eq 0 ]; then
			tar -xvf "$3.tar.bz2" -C "$SOURCES" >/dev/null
			if [ $? -ne 0 ]; then 
				error_c "Git source :cannot restore from tar backup " "   project $1"
			fi 
			cd "$SOURCES/$1"
			git pull origin master
			if [ $? -ne 0 ]; then 
				error_c "Git Update error " "   project $1"
			fi 			
			RES=1
		fi
		cd "$PWD"
	fi	
	if [  $RES -eq 0 ]; then	
		mkdir  -p "$SOURCES/$1"
		git   clone $PNAME  "$SOURCES/$1"
		if [ $? -ne 0 ]; then 
			error_c "Git clone error " "   project $1"
		else
			#create a backup tar on store to work offline and to untar + pull for  future
			if [ -e "$STORE/$3.tar.bz2" ]; then
				chmod 666 "$STORE/$3.tar.bz2"
				chmod 666 "$STORE/$3.tar.bz2.md5"
			fi
			rm -rf "$STORE/$3.tar.bz2"
			rm -rf "$STORE/$3.tar.bz2.md5"
			cd "$SOURCES"
			tar -cjvSf "$STORE/$3.tar.bz2"  "$1" >/dev/null
			if [ $? -ne 0 ]; then 
				error_c "Git source :cannot create tar backup " "   project $1"
			fi 
			cd "$PWD"
			md5sum "$STORE/$3.tar.bz2" > "$STORE/$3.tar.bz2.md5"				
			chmod 444 "$STORE/$3.tar.bz2"
			chmod 444 "$STORE/$3.tar.bz2.md5"
		fi
	fi
else
	cd "$SOURCES/$1"
	git pull origin master
	if [ $? -ne 0 ]; then 
		error_c "Git Update error " "   project $1"
	fi 
	cd "$PWD"
fi
} #EX

# $1 project name
# $2 link
# $3 filename 
function file_packet(){ #EX
local RES=0
print_c "$GREEN_LIGHT" "   - File copy source $3" "$YELLOW" $1
local PNAME=$2/$3
check_exist $SOURCES/$1/$3
if [ $? -ne 0 ]; then
	rsync -ry $PNAME $SOURCES/$1/$3	
	if [ $? -ne 0 ]; then
		error_c "Cannot copy file $3" " project $1"
	fi
	RES=99
fi
return $RES
} #EX


# $1 project name
# $2 source path with source created
# $3 filename
function apt_packet(){ #EX
print_c "$GREEN_LIGHT" "   - File copy source $3" "$YELLOW" $1
local PWD=$(pwd)
rm -rf /tmp/$3
mkdir -p /tmp/$3
cd  /tmp/$3
apt-get source $3
if [ $? -ne  0 ] ; then 
	error_c "apt-get  fail to download source packet" " project $1"
fi
if [ -d $2 ]; then 
	if [ ! -d "$SOURCES/$1" ]; then
		mkdir -p "$SOURCES/$1"
	fi
	cp -a /tmp/$3/$2/* "$SOURCES/$1"
	if [ $? -ne  0 ] ; then 
		error_c "Cannot copy downloaded source " " project $1"
	fi
fi
cd $PWD
rm -rf /tmp/$3
} #EX


# $1 file out
# $2 method download
# $3 url
# $4 file
# $5 packet name
# $6 status
# $7 key url
# $8 key file
function write_download_mode(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	set -x
	STEP_STEP=1
fi
[ $STEP_STEP -eq 1 ] && trap read debug
echo "" >>  "$1"
echo "" >>  "$1"
case  $2 in
	"WGET")
	echo "wget_packet $5 $3 $4 $7 $8">> "$1"
	;;
	"GIT")
	echo "git_packet $5 $3 $4 ">> "$1"
	;;
	"SVN")
	echo "svn_packet $5 $3 $4 ">> "$1"
	;;
	"FILE")
	echo "file_packet $5 $3 $4 ">> "$1"
	;;
	"APT")
	echo "apt_packet $5 $3 $4">> "$1"
	;;
	*)
	error_c "Unknow method to get sources " "$2 - project : $7"
	;;
esac 
}


# $1 file out
# $2 method download
# $3 url
# $4 file
# $5 packet name
# $6 status
# $7 key url
# $8 key file
function create_download_source(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
# $1=--force or not
echo "if [ \$# -ne 0 ]; then">> "$1"
echo "  case \$1 in ">> "$1"
echo "    -F|--force)">> "$1"
echo "     if [ -f \"$STORE/\$4\" ]; then" >> "$1"
echo "       rm  -f  \"$STORE/\$4\"" >> "$1"
echo "       rm  -f  \"$STORE/\$4.*\"" >> "$1"
echo "     fi ">> "$1"
echo "     if [ -d \"$SOURCES/\$7\" ]; then" >> "$1"
echo "       rm -rf  \"$SOURCES/\$7\"" >> "$1"
echo "     fi ">> "$1"
echo "     ;;">> "$1"
echo "  esac">> "$1"
echo "fi">> "$1"
echo "">> "$1"
echo "">> "$1"
echo "ROOT=$ROOT">> "$1"
echo "REPO=$REPO">> "$1"
echo "SOURCES=$SOURCES">> "$1"
echo "IMAGES=$IMAGES/$STEP_NAME">> "$1"
echo "REPOBACKUP=$REPOBACKUP">> "$1"
echo "BUILD=$BUILD/$STEP_NAME">> "$1"
echo "STORE=$STORE">> "$1"
echo "STATUS=$BUILD/$STEP_NAME/$6/status">> "$1"
echo "export PATH=$MYPATH">> "$1"
echo "check_exist \$STATUS">> "$1"
echo "if [ \$? -eq 0 ]; then ">> "$1"
echo "   chmod +w \$STATUS" >> "$1"
echo "fi" >> "$1"
echo "ex_setbuildstatus 0" >> "$1"
write_download_mode $@
}

#$1 source path
#$2 file
#$3 sign file
# ex file.tar & file.tar.sign ok check
# ex file.tar.gz  & file.tar.gz.sign  ok ckeck
# ex file.tar.gz  & file.tar.sign -> gunzip tar and check 
function test_sign_file(){ #EX
local RES=100
local OUTNAME="$2"
local BNAME_FILE=$(basename $2)
local BNAME_SIGN=$(basename $3)
local EXT=${BNAME_FILE##*.}
local V=$(echo $BNAME_SIGN | grep $EXT )
local TT=$(echo $EXT |   tr '[:lower:]' '[:upper:]')
if [ ! $V ]; then 
	OUTNAME="$1/"$(echo $BNAME_FILE | sed "s/.$EXT//g")
	V=$(ls -al "$OUTNAME" )
	if [  !  -f  "$OUTNAME"  ]; then
		#no match V="" expand file 
		case $TT in
			"XZ")		
				unxz "$2"
				touch "$2"
			;;
			"GZ")
				gunzip "$2"
				touch "$2"
			;;
			"BZ2")
				bzip2 -d  "$2"
				touch "$2"
			;;
			*)
			error_c "Unknow methos for ext $EXT  " "$i - project : $3"
			;;
		esac
	fi
fi
echo $OUTNAME
} #EX

# verify pgp sign 
#$1 file
#$2 remote file.sig
#$3 project
#$4 ext sig,asc,gpg
function check_pgp(){ #EX
local RES=0
local KEYS=""
#trap read debug
if [ ! -f  $1.$4 ]; then 
	wget   --show-progress -q "$2" -O "$1.$4"
	RES=$?
	if [ $RES -eq 8 ]; then 
	#file not found
		rm -f "$1.$4"
		return $RES
	fi		
fi	

tmp=$(getFileSize  "$1.$4" )
if [  "$tmp" != "0"  ]; then	
        gpg --quiet --verify    "$1.$4" 
        RES=$?
        if [ $RES -eq 0 ]; then
                chmod 444 "$1"
                chmod 444 "$1.$4"
		#add md5sum to quick chek file after chek with gpg
		md5sum "$1" >"$1.md5"
		chmod 444 "$1.md5"
		print_c "$GREEN_LIGHT" "   - Add MD5 to verified file to quickly check" "$YELLOW" $3
                RES=1
        else
                warning_c "gpg chek fail " "file  $2" "have to import the public key" "(gpg --recv-key <xxxxxxxx> )" "or bad sign" "project $3"
		rm -f  "$1.$4"
		#RES=$?
                if [ $RES -ne 1 ]; then
                                RES=8
                fi
        fi
else
        rm -f  "$1.$4"
fi
return $RES
} #EX



# verify md5 sum 
#$1 file
#$2 remote file.md5
#$3 project
function check_md5sum(){ #EX
local RES=0
if [ ! -f  $1.md5 ]; then 
	wget   --show-progress -q "$2.md5" -O "$1.md5"
	RES=$?
	if [ $RES -eq 8 ]; then 
	#file not found
		rm -f "$1.md5"
		return $RES
	fi			
fi	

md5sum  -c "$1.md5" >  /dev/null 
if [ $? -eq 0 ]; then
	chmod 444 "$1"
	chmod 444 "$1.md5"
	RES=1
else
	print_c "$RED_LIGHT" "   - MD5 check source FAIL" "$YELLOW" $3	 
	chmod 666 "$1"
	chmod 666 "$1.md5"
	rm -f "$1.md5"
	rm -f "$1"
	RES=99
fi 
return $RES
} #EX

# verify sha1 sum 
#$1 file
#$2 remote file.sha1
#$3 project
function check_sha1sum(){ #EX
local RES=0
if [ ! -f  $1.sha1 ]; then
	wget    --show-progress -q "$2.sha1" -O "$1.sha1"
	RES=$?
	if [ $RES -eq 8 ]; then 
	#file not found
		rm -f "$1.sha1"
		return $RES
	fi	
fi	
#	tmp=$( ls -al  "$1.sha1"  |  awk  '{print $5}' )
#	if [  $tmp -ne 0 ]; then
		sha1sum  -c "$1" > /dev/null
		if [ $? -eq 0 ]; then
			chmod 444 "$1"
			chmod 444 "$1.sha1"
			RES=1
		else
			print_c "$RED_LIGHT" "   - SHA1 check source FAIL" "$YELLOW" $3	
			rm -f "$1.sha1"
			rm -f "$1"
			RES=99
		fi 
#	else
#		rm -f  "$1.sha1"	
#	fi
return $RES
} #EX

#$1 filename 
#$2 remote repository
#$3 project
#$4 custom sign file name 
function check_sign(){ #EX
local RES=0
local ASIGN=" md5 sig sha1 sign asc"
local i=""
for i in $ASIGN; do
 case $i in
	"sig"|"sign"|"asc")
	if [ $4 -eq 1 ]; then 
		check_pgp $1 $2 $3 $i  
	else
		check_pgp $1 "$2.$i" $3 $i  
	fi
	RES=$?	
	;;
	"md5")
	if [ $4 -eq 1 ]; then 
		check_md5sum $1 $2 $3
	else
		check_md5sum $1 "$2.$i" $3
	fi
	RES=$?
	;;
	"sha1")
	if [ $4 -eq 1 ]; then 
		check_sha1sum $1 $2 $3
	else
		check_sha1sum $1 "$2.$i" $3
	fi
	RES=$?
	;;
	*)
	error_c "Unknow sign " "$i - project : $3"
	;;	
esac 
if [ $RES -eq 1 ] || [ $RES -eq 99 ]; then 
	break
fi
done
return $RES
} #EX


# get a packet from internet
# $1 project name
# $2 link
# $3 filename 
# $4 sign key furl
# $5  sign key file
function wget_packet(){ #EX
local RES=0
local DOWN=0
local STATUS=0
local CUSTOM=0
local FILEIN=""
local EXT=""
local VV=$(echo $3 | grep $1) 
if [ "$VV" == "" ]; then 
# in case of : ex dwload v2.4rev1 -> ($1)-v2.4rev1
	VV="$1-$3"
else
	VV=$3
fi
FILEIN="$STORE/$VV"
print_c "$GREEN_LIGHT" "   - Download $1" "$YELLOW" $VV
local PNAME="$2/$3"
if [ -f "$FILEIN.status" ]; then 
	STATUS=$(cat  "$FILEIN.status")
	if [ $STATUS -eq 1 ] ; then
		# previous download ended ok all exit
		if [ ! -e "$SOURCES/$1" ] ; then
			mkdir -p "$SOURCES/$1"				
			#echo "-->tar -xf $REPO/$1/$3 -C  $SOURCES/$1"			
			EXT=$( echo ${FILEIN##*.}  | tr '[:lower:]' '[:upper:]' )
			if [ "$EXT"  ==  "ZIP" ]; then 
				unzip -u "$FILEIN"  -d "$SOURCES/$1"
			else
				tar -xf "$FILEIN" -C  "$SOURCES/$1"
			fi			
			if [ $? -ne 0 ]; then
				rm -f "$FILEIN"
				rm -f "$FILEIN.*"
			else
				return $RES			
			fi
		fi
	else	
		rm -f "$FILEIN"
		rm -f "$FILEIN.*"
	fi
else
	rm -f "$FILEIN"
	rm -f "$FILEIN.*"
fi
tmp=$(getFileSize "$FILEIN")
if [ "$tmp" == "0" ]; then
	rm -f "$FILEIN"
	wget    --show-progress -q "$PNAME" -O "$FILEIN"
	RES=$?
	if [ $RES -ne 0 ]; then
		error_c  "Wget fail : error $RES " " file $PNAME project $1"
	else
		DOWN=1
	fi
else
	print_c "$GREEN_LIGHT" "   - Checking $1 source from local store " "$YELLOW" "$tmp bytes"
fi
if [  $4 ] && [ $5 ]; then
		FILEIN=$(test_sign_file "$STORE" "$FILEIN" "$4/$5") 		
		PNAME="$4/$5"
		CUSTOM=1
	fi
tmp=$(getFileSize "$FILEIN")	
if [ "$tmp" != "0" ]; then	
	if [ $FAIL  -lt 3 ]; then 
		check_sign "$FILEIN" "$PNAME" "$1" "$CUSTOM"
		RES=$?
		if [ $RES -eq 99 ]; then 
			FAIL=$((FAIL+1))		
			wget_packet $1 $2 $3 $4 $5
		fi
	else
		RES=8
	fi	
	if [ $RES -eq 8 ]; then
	warning_c "No sign file found !" "$VV" "add md5sum to it"
	md5sum "$FILEIN" > "$FILEIN.md5"
	chmod 444 	 "$FILEIN.md5"
	RES=1
	fi
	if [ $RES -eq 1 ]; then 
		if [ ! -e "$SOURCES/$1" ] ; then
			mkdir -p "$SOURCES/$1"
		fi
		if [ ! -d "$SOURCES/$1" ]; then 
			rm -rf "$SOURCES/$1"
			mkdir -p "$SOURCES/$1"
		fi
		
		#echo "-->tar -xf $REPO/$1/$3 -C  $SOURCES/$1"
		EXT=$( echo ${FILEIN##*.}  | tr '[:lower:]' '[:upper:]' )
		if [ "$EXT"  ==  "ZIP"  ]; then 
			unzip -u "$FILEIN"   -d "$SOURCES/$1"
		else
			tar -xf "$FILEIN" -C  "$SOURCES/$1"
		fi		
		if [ $? -ne 0 ]; then
			error_c "Unable to untar file " "$REPO/$1/$3 project $1"
		fi
		echo 1 > "$FILEIN.status"
	fi
fi
if [ $RES -eq 1 ] && [ $DOWN -eq 1 ] ; then 
   RES=99; 
else
	if [ $RES -eq 1 ] && [ $DOWN -eq 0 ] ; then 
	RES=0
	fi
fi
return $RES
} #EX



# $1 packet name
# $2 step
# $3 build
# $4 file out
function get_source_param_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local RES=0
local tmp=""
local REMOTE=""
local MODE=""
local PACKET=""
local NUM=0
local KEY_URL=""
local KEY_FILE=""
local BRANCH=""
check_project $1
if [ $? -eq 1 ]; then
#exist project name <name> in repo 
#load prj/conf.egg to download the packet
#conf.h REMOTE link packet name md5sum
	if [ -f $REPO/$1/conf.egg ]; then
		MODE=$(xml_value $1 "/egg/project/remote/method")
		equs "$MODE"  
		if [ $? -eq 1 ]; then 
			error_c "Missing  download mode" "project : $1"
		fi
		REMOTE=$(xml_value $1 "/egg/project/remote/url")
		equs "$REMOTE" 
		if [ $? -eq 1 ]; then 
			error_c "Missing remote repository name" "project : $1"
		fi
		PACKET=$(xml_value $1 "/egg/project/remote/file")
		equs "$PACKET" 
		if [ $? -eq 1 ]; then 
			error_c "Missing  packet name " "project : $1"
		fi			
		xml_count $1 "/egg/project/remote/key"
		NUM=$?
		if [ $NUM -ne 0 ]; then 
			KEY_URL=$(xml_value $1 "/egg/project/remote/key/url")
			equs "$KEY_URL" 
			if [ $? -eq 1 ]; then 
				error_c "Missing  key url " "project : $1"
			fi
			KEY_FILE=$(xml_value $1 "/egg/project/remote/key/file")
			equs "$KEY_FILE" 
			if [ $? -eq 1 ]; then 
				error_c "Missing  key file " "project : $1"
			fi
		fi
		MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
		#check  git for branch...
		if [ "MODE" == "GIT" ]; then
			xml_count $1 "/egg/project/remote/branch"	
			NUM=$?
			if [ $NUM -ne 0 ]; then 
				BRANCH=$(xml_value $1 "/egg/project/remote/branch")
				equs "$BRANCH" 
				if [ $? -eq 1 ]; then 
					error_c "Missing  branch  " "project : $1"
				fi
				tmp="-b $BRANCH $REMOTE"
				REMOTE="$tmp"
			fi
		fi
		prepare_script_download "$1" "$2"  "$4" "$3" 
		create_download_source "$4"  "$MODE"  "$REMOTE" "$PACKET"  "$1"  "$1_$2" "$KEY_URL" "$KEY_FILE" 
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}




# $1 packet name
# $2 step
# $3 build
# $4 file out
function get_patch_param_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local -i tmp=0
local -i i=0
local REMOTE=""
local MODE=""
local PACKET=""
local KEY_URL=""
local KEY_FILE=""
local PATCH_DIR=""
local DEST_DIR=""
local AID=0
check_project $1
if [ $? -eq 1 ]; then
#exist project name <name> in repo 
#load prj/conf.egg to download the packet
#conf.h REMOTE link packet name md5sum
	if [ -f $REPO/$1/conf.egg ]; then		
		xml_count $1 "/egg/project/patch"
		tmp=$?
		if [ $tmp -ne 0 ]; then
			while [ $i -lt $tmp ]; do
				MODE=$(xml_value $1 "/egg/project/patch[@id='$i']/method")
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  patch download mode" "project : $1"
				fi
				REMOTE=$(xml_value $1 "/egg/project/patch[@id='$i']/url")
				equs "$REMOTE" 
				if [ $? -eq 1 ]; then 
					error_c "Missing patch remote repository name" "project : $1"
				fi
				PACKET=$(xml_value $1 "/egg/project/patch[@id='$i']/file")
				equs "$PACKET" 
				if [ $? -eq 1 ]; then 
					error_c "Missing  patch packet name " "project : $1"
				fi	
				xml_count $1 "/egg/project/patch[@id='$i']/key"
				NUM=$?
				if [ $NUM -ne 0 ]; then 
					KEY_URL=$(xml_value $1 "/egg/project/patch[@id='$i']/key/url")
					equs "$KEY_URL" 
					if [ $? -eq 1 ]; then 
						error_c "Missing  key url " "project : $1"
					fi
					KEY_FILE=$(xml_value $1 "/egg/project/patch[@id='$i']/key/file")
					equs "$KEY_FILE" 
					if [ $? -eq 1 ]; then 
						error_c "Missing  key file " "project : $1"
					fi
				fi
				xml_count $1 "/egg/project/patch[@id='$i']/dir"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					PATCH_DIR=$(xml_value $1 "/egg/project/patch[@id='$i']/dir")	
				else
					PATCH_DIR=""
				fi
				xml_count $1 "/egg/project/patch[@id='$i']/dest_dir"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					DEST_DIR=$(xml_value $1 "/egg/project/patch[@id='$i']/dest_dir")	
				else
					DEST_DIR=""
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]') 
				prepare_script_download "$1" "$2"  "$4" "$3"
				create_download_source "$4"  "$MODE"  "$REMOTE" "$PACKET"  "$1"  "$1_$2" "$KEY_URL" "$KEY_FILE"
				if [ "$PATCH_DIR" ] ; then
					xml_count $1 "/egg/project/patch[@id='$i']/apply"
					NUM=$?
					if [ $NUM -ne 0 ]; then
						AID=0
						while [ $AID -lt $NUM ]; do
							PACKET=$(xml_value $1 "/egg/project/patch[@id='$i']/apply[@id='$AID']")
							write_apply_patch "$4"  "$(getSourcePath $1)" "$(getSourcePath $1)/$PATCH_DIR/$PACKET" "$1"
							AID=$((AID+1))
						done
					else
						write_apply_patch "$4"  "$(getSourcePath $1)" "$(getSourcePath $1)/$PATCH_DIR" "$1"
					fi
				else
					if [ "$DEST_DIR" ] ; then
						write_apply_patch "$4"  "$(getSourcePath $1)/$DEST_DIR" "$SOURCES/$1/$PACKET" "$1"
					else
						write_apply_patch "$4"  "$(getSourcePath $1)" "$SOURCES/$1/$PACKET" "$1"
					fi
				fi
				i=$((i+1))
			done 	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}

#$1 project
#$2 build phase number 0,1,2.....
#$3 make priority
#$4 build name
function check_source(){ 
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local -i RES=0
local S_BUILD="$BUILD/$STEP_NAME/$1_$2"
mkdir -p "$BUILD"
mkdir -p "$BUILD/$STEP_NAME"
mkdir -p "$S_BUILD"
local S_FILE="$S_BUILD/download.sh"
rm -f "$S_FILE"
touch "$S_FILE"
print_ita  "CONF : $1"  "$2"  "download source"
get_source_param_packet "$1" "$2" "$4" "$S_FILE" 
RES=$(getFileSize $S_FILE)
if [ $RES -ne 0 ]; then
	end_script_generic "$1" "$2" "$4" "$S_FILE" 
fi
chmod +x "$S_FILE"
}



#$1 project
#$2 build phase number 0,1,2.....
#$3 make priority
#$4 build name
function check_patch(){ 
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local -i RES=0
local S_BUILD="$BUILD/$STEP_NAME/$1_$2"
local S_FILE="$S_BUILD/patch.sh"
rm -f "$S_FILE"
touch "$S_FILE"
print_ita  "CONF : $1"  "$2"  "patch source"
get_patch_param_packet "$1" "$2" "$4" "$S_FILE" 
if [ $RES -ne 0 ]; then
	end_script_generic "$1" "$2" "$4" "$S_FILE" 
fi
chmod +x "$S_FILE"
}

#$1 project
#$2 build phase number 0,1,2.....
#$3 make priority
#$4 build name
function configure_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
manage_path_pre  $1  $2
create_configure_cmd "$1" "$2" "$3"
manage_path_post $1  $2
create_main_scripts $@
sync
}


#$1 build phase number 0,1,2.....
function read_default_for_step(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local VV=""
local VALUE=""
local VAR=""
local NAMES="step_name info cc cxx as ld nm ar strip asflags cflags cppflags cxxflags \
			ldflags libs cpath c_include_path cplus_include_path \
			arch cross cross_compile"
VV=$(getFileSize $REPO/conf.egg)
if [ $VV -ne 0 ]; then
	NUM=$(xmlstarlet sel -t  -v "count(/egg/defaults/step[@id=\"$1\"])" -n $REPO/conf.egg)	
	if [ $NUM -eq 1 ]; then
		for VV in $NAMES; do
			VAR=$(echo $VV |   tr '[:lower:]' '[:upper:]')
			VALUE=$(xmlstarlet sel -t  -v "egg/defaults/step[@id=\"$1\"]/$VV" -n $REPO/conf.egg)
			if [ "$VALUE" ]; then 	
					#print_ita "Set   ($1) " "$VAR" "$VALUE"
					eval $VAR='$VALUE'
					export "$VAR"
			else
				#print_ita "Unset ($1) " "$VAR" "..."
				unset "$VAR"	
			fi
		done
	else
		if [ $NUM -eq 0 ]; then
			warning_c "missing defaults conf for step $1"
		else
			error_c "errata conf in main conf.egg" "Step id=$1 duplicate" 
		fi
	fi
else
	error_c "Missing conf.egg file " "on repo"
fi
NATIVE=$(gcc -dumpmachine)
}



#$1 number id
#$@ argv optional
function conf_download_all(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
#set -x; trap read debug
local V=""
isNumber $1
if [ $? -ne 0 ]; then
	error_c "first input param must be the step number!" "source <step x> <optional projets>"
fi

local ID=$1
local PRJS=""
local PRI=""
local NAME=""
shift

if [ "$#" -eq  0 ]; then
	PRJS=$ALL_PACKETS
else
	PRJS=$@
fi


prepare_seq_download "$ID" "$PRJS"

MYPATH=$PATH
V=${SORTREQ[0]}
if [ "$V" ]; then	
	if [ ! -e "$BUILD/$STEP_NAME" ]; then
		mkdir -p "$BUILD/$STEP_NAME"
	fi
	
	for V in $SORTREQ; do
		PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
		PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')		
		if [ "$PRJS" ] ; then 
			check_source  "$PRJS" "$ID" "$PRI" "$STEP_NAME"
		fi
	done
fi	
}



#$1 number id
#$@ argv optional
function conf_patch_all(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
#set -x; trap read debug
local V=""
isNumber $1
if [ $? -ne 0 ]; then
	error_c "first input param must be the step number!" "patch <step x> <optional projets>"
fi

local ID=$1
local PRJS=""
local PRI=""
local NAME=""
shift

if [ "$#" -eq  0 ]; then
	PRJS=$ALL_PACKETS
else	
	PRJS=$@
fi

prepare_seq_download "$ID" "$PRJS"

MYPATH=$PATH
V=${SORTREQ[0]}
if [ "$V" ]; then	
	if [ ! -e "$BUILD/$STEP_NAME" ]; then
		mkdir -p "$BUILD/$STEP_NAME"
	fi
	
	for V in $SORTREQ; do
		PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
		PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')		
		if [ "$PRJS" ] ; then 
			check_patch  "$PRJS" "$ID" "$PRI" "$STEP_NAME"
		fi
	done
fi	
}


#$1 number id
#$@ argv optional
function configure_all_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
#set -x; trap read debug
local V=""
isNumber $1
if [ $? -ne 0 ]; then
	error_c "first input param must be the step number!" "gen <step x> <optional projets>"
fi

local ID=$1
local PRJS=""
local PRI=""
local NAME=""
shift

if [ "$#" -eq  0 ]; then
	PRJS=$ALL_PACKETS
else
	PRJS=$@
fi


prepare_seq_priority "$ID" "$PRJS"

MYPATH=$PATH
V=${SORTREQ[0]}
if [ "$V" ]; then
	PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
	PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')	
	if [ ! -e "$BUILD/$STEP_NAME" ]; then
		mkdir -p "$BUILD/$STEP_NAME"
	fi
	prepare_script_head "$BUILD/$STEP_NAME/step_$ID.sh"	
	echo "#START_FUNCTION_STEP">>"$BUILD/$STEP_NAME/step_$ID.sh"
	for V in $SORTREQ; do
		PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
		PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')		
		if [ "$PRJS" ] ; then 
			configure_packet  "$PRJS" "$ID" "$PRI" "$STEP_NAME"
		fi
	done
	create_main_entry "$PRJS" "$ID" "$PRI" "$STEP_NAME"
fi	
}



#$1 ID BUILD STEP
#$2 array of project
function prepare_seq_priority(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local V=""
unset BSEQ
declare -A BSEQ
read_default_for_step "$1"
for V in $2; do
	insert_packet $V $1
done	
SORTREQ=$(echo ${BSEQ[*]}| tr " " "\n" | sort -n )
}



#$1 ID BUILD STEP
#$2 array of project
function prepare_seq_download(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local V=""
unset BSEQ
declare -A BSEQ
read_default_for_step "$1"
for V in $2; do
	insert_packet_download  $V $1
done	
SORTREQ=$(echo ${BSEQ[*]}| tr " " "\n" | sort -n )
}

#set numero massimo di step a disposizone
function get_max_step(){
MAX_STEP=$(xmlstarlet sel -t  -v "count(/egg/defaults/step)" -n $REPO/conf.egg)
}




#print build start 
#$1 pririty
#$2 name
#$3 project
function print_build_msg(){
print_ita  "BUILD : $1"  "$2"  "$3"
}

#print build start 
#$1 pririty
#$2 name
#$3 project
function print_conf_msg(){
print_ita  "CONF  : $1"  "$2"  "$3"
} 

 
#$1 pririty
#$2 name
#$3 project
function print_clean_msg(){
print_ita  "CLEAN : $1"  "$2"  "$3"
}

#$1 pririty
#$2 name
#$3 project
function print_download_msg(){
print_ita  "DWLOAD: $1"  "$2"  "$3"
} 



#$1 pririty
#$2 name
#$3 project
function print_patch_msg(){
print_ita  "PATCH: $1"  "$2"  "$3"
} 


#none
function packetize_all(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
local STATUS=0
local RESULT=0
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority "$ID" "$ALL_PACKETS"
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [[ $(getFileSize "$BUILD/$PRJ/$NAME/status") != "0" ]]; then
			STATUS=$(cat "$BUILD/$PRJ/$NAME/status")
			if [ $STATUS -ne 2 ]; then
				RESULT=1
				break
			fi
		fi
	done
	ID=$((ID+1))
done
if [ $RESULT -eq 0 ]; then 	
	local PWD=$(pwd)
	start_time=$(date +%s)
	print_ita "PKT" "$PRJ" "..." 
	V=$(getFileSize $IMAGES/$PRJ.tar.bz2)
	if [  $V -ne 0  ]; then  
		rm -f $IMAGES/$PRJ.tar.bz2 
		rm -f $IMAGES/$PRJ.tar.bz2.md5
	fi
	cd "$IMAGES/$PRJ"
	tar -cjSf $IMAGES/$PRJ.tar.bz2   .
	md5sum $IMAGES/$PRJ.tar.bz2 > $IMAGES/$PRJ.tar.bz2.md5
	cd $PWD
	ID=0;
	while [ $ID -lt $MAX_STEP ] ; do
		prepare_seq_priority "$ID" "$ALL_PACKETS"
		for V in $SORTREQ; do
			V=$(echo $V  | sed -e 's/%/   /g')
			PRI=$(echo $V | awk '{print $1}')
			NAME=$(echo $V | awk '{print $2}')"_$ID"
			PRJ=$(echo $V | awk '{print $3}')
			rm -rf $BUILD/$PRJ/$NAME/build
			rm -rf $BUILD/$PRJ/$NAME/*.log
			mkdir -p $BUILD/$PRJ/$NAME/build
		done
		ID=$((ID+1))
	done
	stop_time=$(date +%s)
	total_time=$((stop_time-start_time))
	print_ita "$PRJ.tar.bz2"  "$(getFileSize $IMAGES/$PRJ.tar.bz2 ) Bytes"  "$total_time sec"
else
	error_c "$PRJ contain packages not ready to packetize " "project : $NAME" 
fi
print_del_ita
}



#$1 function to execute
#$2 ID step build
#$3 ... SN projects
#$@ from argv build.sh
function exec_single(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
#trovo nomi build per ogni progetto
local ID=0
local PRI=""
local NAME=""
local PRJ=""
local SEQ=""
local FUNCTION=""
local FBUILD=""
if [ ! "$1" ]; then
	error_c "Input missing function to execute  !!"
fi
FUNCTION="$1  "
isNumber $2
if [ $? -ne 0 ]; then
   error_c "$2 : Input step isn't a number !!"
fi
ID=$2
if [ ! "$3" ]; then
	PRJ=$ALL_PACKETS
else
	PRJ=$3
fi
shift
shift


local PWD=$(pwd)
prepare_seq_priority "$ID" "$PRJ"

for T in $SORTREQ; do
	SEQ=$(echo $T  | sed -e 's/%/   /g')
	PRI=$(echo $SEQ | awk '{print $1}')
	NAME=$(echo $SEQ | awk '{print $2}')"_$ID"
	PRJ=$(echo $SEQ | awk '{print $3}')
	FBUILD="$BUILD/$PRJ/$NAME"
	if [ -d "$FBUILD" ]; then
		$FUNCTION   "$PRI" "$NAME" "$PRJ" "$FBUILD"
	fi
done

}


#$1 function to execute
#$2 ID step build
#$3 ... SN projects
#$@ from argv build.sh
function exec_single_download(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
#trovo nomi build per ogni progetto
local ID=0
local PRI=""
local NAME=""
local PRJ=""
local SEQ=""
local FUNCTION=""
local FBUILD=""
if [ ! "$1" ]; then
	error_c "Input missing function to execute  !!"
fi
FUNCTION="$1  "
isNumber $2
if [ $? -ne 0 ]; then
   error_c "$2 : Input step isn't a number !!"
fi
ID=$2
if [ ! "$3" ]; then
	PRJ=$ALL_PACKETS
else
	PRJ=$3
fi
shift
shift


local PWD=$(pwd)
prepare_seq_download "$ID" "$PRJ"
for T in $SORTREQ; do
	SEQ=$(echo $T  | sed -e 's/%/   /g')
	PRI=$(echo $SEQ | awk '{print $1}')
	NAME=$(echo $SEQ | awk '{print $2}')"_$ID"
	PRJ=$(echo $SEQ | awk '{print $3}')
	FBUILD="$BUILD/$PRJ/$NAME"
	if [ -d "$FBUILD" ]; then
		$FUNCTION   "$PRI" "$NAME" "$PRJ" "$FBUILD"
	fi
done
}

function exec_build(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_build_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/bootstrap.sh"
if [ $? -ne 0 ] ; then
	error_c "configure step" " FAIL !!";
fi
"$PATH/build_$PRI.sh"
if [ $? -ne 0 ] ; then
	error_c "build step" " FAIL !!";
fi
cd $OROOT
}

#$@ from argv build.sh
function build_single(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ARGV="$@"
exec_single "exec_build" $ARGV
}



function exec_download(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_download_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/download.sh"
if [ $? -ne 0 ] ; then
	error_c "download step" " FAIL !!";
fi
cd $OROOT
}

#$@ from argv build.sh
function download_single(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ARGV="$@"
exec_single_download "exec_download" $ARGV
}


function exec_patch(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_patch_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/patch.sh"
if [ $? -ne 0 ] ; then
	error_c "patch step" " FAIL !!";
fi
cd $OROOT
}

#$@ from argv build.sh
function patch_single(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ARGV="$@"
exec_single_download "exec_patch" $ARGV
}

function exec_compile(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_build_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/build_$PRI.sh"
if [ $? -ne 0 ] ; then
	error_c "build step" " FAIL !!";
fi
cd $OROOT
}

#$@ from argv build.sh
function compile_single(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ARGV="$@"
exec_single "exec_compile" $ARGV
}


function exec_clean(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_clean_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/clean.sh"
if [ $? -ne 0 ] ; then
	error_c "clean step" " FAIL !!";
fi
cd $OROOT
}

#$@ from argv build.sh
function clean_single(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ARGV="$@"
exec_single "exec_clean" $ARGV
}

function exec_distclean(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_clean_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/distclean.sh"
if [ $? -ne 0 ] ; then
	error_c "distclean step" " FAIL !!";
fi
cd $OROOT
}

#$@ from argv build.sh
function distclean_single(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ARGV="$@"
exec_single "exec_distclean" $ARGV
}


#$@
function build_all_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		local -i CONF_NUM=$1
		shift
		build_single $CONF_NUM $@
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi
print_del_ita
}

#$@
function download_all_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		local -i CONF_NUM=$1
		shift
		download_single $CONF_NUM $@
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi
print_del_ita
}

#$@
function patch_all_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		local -i CONF_NUM=$1
		shift
		patch_single $CONF_NUM $@
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi
print_del_ita
}

#$@
function compile_all_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		local -i CONF_NUM=$1
		shift
		compile_single $CONF_NUM $@
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi
print_del_ita
}

#$@
function clean_all_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		local -i CONF_NUM=$1
		shift
		clean_signle $CONF_NUM $@
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi
print_del_ita
}

#$@
function distclean_all_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		local -i CONF_NUM=$1
		shift
		distclean_single $CONF_NUM $@
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi	
print_del_ita
}



#$ARGV TODO
function config_all_step(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local -i CONF_NUM=0
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		local -i CONF_NUM=$1
		shift
		configure_all_packet $CONF_NUM $@
		if [ $? -ne 0 ]; then 
			error_c "configure step $CONF_NUM " " FAIL !!";
		fi
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi
print_del_ita
}

#$ARGV TODO
function conf_download_all_step(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local -i DW_NUM=0
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		DW_NUM=$1
		shift
		conf_download_all $DW_NUM $@
		if [ $? -ne 0 ]; then 
			error_c "configure download step $DW_NUM " " FAIL !!"
		fi
	else
		error_c " Missing step number " "usage ./egg source 0<-- step "
	fi
fi
}


#$ARGV TODO
function conf_patch_all_step(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local -i DW_NUM=0
if [ $# -eq 0 ]; then
	error_c "Missing Param " "insert step number please"
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		DW_NUM=$1
		shift
		conf_patch_all $DW_NUM $@
		if [ $? -ne 0 ]; then 
			error_c "configure patch step $DW_NUM " " FAIL !!";
		fi
	else
		error_c " Missing step number " "usage ./egg patch 0<-- step "
	fi
fi
}

#$ARGV 
# ex 0 gcc -> try step of project gcc
function shell_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRJ=""
local V=""
local i=""
local NUM=$1
isNumber $1
if [ $? -ne 0 ]; then
   error_c "$1 : Input step isn't a number !!"
fi
if [ ! "$2" ]; then
	if [ $NUM -lt $MAX_STEP ]; then
		prepare_seq_priority "$NUM" "$ALL_PACKETS"
		if [ "$SORTREQ" == "" ]; then
			error_c "Step $1 for project $2 not configured!" "project : $2"
		fi
		PRJ=${SORTREQ[0]}
		V=$(echo $PRJ  | sed -e 's/%/   /g')
		NAME=$( echo $V | awk '{print $3}' )
		if [ "$NAME" == "" ]; then			
				error_c "Step $1 unknown name!" "project : $2"
		fi
		print_c "$GREEN_LIGHT" "execute cd : $BUILD/$NAME"
		print_c "$GREEN_LIGHT" "do exit to return..."
		cp $HOME/.bashrc /tmp/egg_shellrc
		echo "cd $BUILD/$NAME" >> /tmp/egg_shellrc
		bash --noprofile --rcfile /tmp/egg_shellrc
	else
		error_c "Input step too BIG !!"
	fi	
else
	if [ $NUM -lt $MAX_STEP ]; then
		prepare_seq_priority "$NUM" "$2"
		if [ "$SORTREQ" == "" ]; then
			error_c "Step $1 for project $2 not configured!" "project : $2"
		fi
		for PRJ in $SORTREQ; do
			V=$(echo $PRJ  | sed -e 's/%/   /g')
			NAME=$( echo $V | awk '{print $2}' )
			if [ "$NAME" == "$2" ]; then			
				PRJ=$( echo $V | awk '{print $3}' )
				break;
			fi
		done
		if [ $PRJ ]; then
		#V=$(pwd)
		print_c "$GREEN_LIGHT" "execute cd : $BUILD/$PRJ/$2_$1"
		print_c "$GREEN_LIGHT" "do exit to return..."
		print_c "$GREEN_LIGHT" "do source ./setenv.sh to enter in build environment"
		cp $HOME/.bashrc /tmp/egg_shellrc
		echo "cd $BUILD/$PRJ/$2_$1" >> /tmp/egg_shellrc
		bash --noprofile --rcfile /tmp/egg_shellrc 
		#cd $V	
		set +x
		fi
	else
		error_c "Input step too BIG !!"
	fi
fi
}


#$1 file da formattare 
function format_xml(){
local BK=""
BK="$1_$(date +%s).backup"
cp "$1" "$BK"
if [ $? -eq 0 ]; then
	xmlstarlet fo  "$BK" > "$1.temp"
	if [ $? -eq 0 ]; then
		rm -rf $1
		mv "$1.temp" "$1"
	fi
fi
}

#recussive edit on repo project
#$1 optnional step : if presente edit only projects in this step
function edit_repo_files(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
if  [ "$1" != ""  ] ; then
	isNumber $1
	if [ $? -ne 0 ]; then 
		error_c "Input parameter not is a number" "insert step level "
	fi
fi
local ALL_FILES=$(get_priority_list "$1")
local VV=""
format_xml "$OREPO/conf.egg"
$EDITOR "$OREPO/conf.egg"
for VV in $ALL_FILES;  do
if [ "$VV" == "." ]; then continue; fi
if [ "$VV" == ".." ]; then continue; fi
if [ -d "$OREPO/$VV" ]; then 
	format_xml "$OREPO/$VV/conf.egg"
	$EDITOR "$OREPO/$VV/conf.egg" 
fi
done
}

#recussive format on repo project
#$1 optnional step : if presente edit only projects in this step
function format_repo_files(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
if  [ "$1" != ""  ] ; then
	isNumber $1
	if [ $? -ne 0 ]; then 
		error_c "Input parameter not is a number" "insert step level "
	fi
fi
local ALL_FILES=$(get_priority_list "$1")
local VV=""
format_xml "$OREPO/conf.egg"
for VV in $ALL_FILES;  do
if [ "$VV" == "." ]; then continue; fi
if [ "$VV" == ".." ]; then continue; fi
if [ -d "$OREPO/$VV" ]; then 
	format_xml "$OREPO/$VV/conf.egg"
fi
done
}

#$ARGV 
#  gcc -> edit conf.egg of project gcc
function edit_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRJ=""
local V=""
if [ ! "$1" ]; then
	error_c "Missing Input project "
fi
check_project "$1"
if [ $? -ne 0 ]; then
	format_xml "$OREPO/$1/conf.egg"
	$EDITOR "$OREPO/$1/conf.egg" > /dev/null  &
else
	case $1 in
		self)
		format_xml "$OROOT/egg"
		$EDITOR "$OROOT/egg" > /dev/null  &
		;;
		self.conf)
		format_xml "$OREPO/conf.egg"
		$EDITOR "$OREPO/conf.egg" > /dev/null  &
		;;
		self.repo)
		edit_repo_files "$2"
		;;
		--format)
		format_repo_files "$2"
		;;
		*)
		error_c "Missing project in $OREPO " "project : $1"
		;;
	esac	
fi
}


function cat_project(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug

if [ ! "$1" ]; then
	error_c "Missing Input project "
fi
check_project "$1"
if [ $? -ne 0 ]; then
	format_xml "$OREPO/$1/conf.egg"
	cat "$OREPO/$1/conf.egg"
else
error_c "Missing project in $OREPO " "project : $1"
fi
}

function show_info(){
print_ita "author" "Angelo" "Coppi"
print_ita "email" "angelogkcop@" "hotmail.com"
print_ita "git" "https://github.com" "ataima"
exit 0
}


#$ARGV
function source_download(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
#if source 1 remove all sources folder else skip remove for souce 1 lzip
if [ $# -eq 1 ]; then
	isNumber $1
	if [ $? -eq 0 ]; then	
		rm -rf $SOURCES
	fi
fi	
conf_download_all_step $@
download_all_packet $@
conf_patch_all_step $@
patch_all_packet $@
}
#$ARGV
function redoall(){
local RE_NUM=0
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
while [ $RE_NUM -lt $MAX_STEP ]; do 
		source_download	 $RE_NUM
		config_all_step	 $RE_NUM
		build_all_packet	 $RE_NUM
		RE_NUM=$((RE_NUM+1))
done	
}

#$1 staus 0,1,2,...?
function getStatusString(){
if [ $1 -eq 0 ]; then 
	echo -n "none";
else		
	if [ $1 -eq 1 ]; then
		echo -n "ready";
	else	
		if [ $1 -eq 2 ]; then 
			echo -n "stable";
			else
				if [ $1 -eq 1000 ]; then 
					echo -n "to configure";
				else
					echo -n "$1: unknow";
			fi
		fi	
	fi
fi
}

#$1 if present only this level
function get_priority_list(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PRI_LIST=""
local ID=0 
local V=""
local NAME=""
isNumber $1
if [ $? -eq 0 ]; then 
	ID=$1
	prepare_seq_priority "$ID" "$ALL_PACKETS"
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		NAME=$(echo $V | awk '{print $2}')
		V=$(echo $PRI_LIST  | grep $NAME)
		if [ "$V" == "" ]; then 
			PRI_LIST="$PRI_LIST $NAME"
		fi
	done
else
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority "$ID" "$ALL_PACKETS"
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		NAME=$(echo $V | awk '{print $2}')
		V=$(echo $PRI_LIST  | grep $NAME)
		if [ "$V" == "" ]; then 
			PRI_LIST="$PRI_LIST $NAME"
		fi
	done
	ID=$((ID+1))
done
fi
echo $PRI_LIST
}


# $1 optional 
function list(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
local STMIN=10000
local PATTERN=""
local ONESTEP=0
isNumber $1
if [ $? -eq 0 ]; then 
	ID=$1
	ONESTEP=1
	shift
fi
#is $1 then chek if a var to list-> list deploy -> ls $DEPLOY
if [ $# -ne 0 ] && [ "$1" != "" ] && [ "$1" != "-" ]; then
	V=$(echo $1  | tr '[:lower:]' '[:upper:]')	
	PRI=$(env | grep $V)
	if [ "$PRI" != "" ]; then 	
		NAME=$( echo $PRI | sed -e 's/=/ /g' | awk '{print $2}' )		
		shift
		if [ "$1" == "" ]; then 
				tree -L 1 "$NAME"
			else
				while [ "$1" != "" ]; do
				isNumber $1
				if [ $? -eq 0 ]; then 
					tree -L "$1" "$NAME"
					break
				else
					NAME="$NAME/$1"
					tree -L 1 "$NAME"
				fi
				shift
				done
			fi 	
	else
		error_c "missing VAR" "Var $1 not in current env"
	fi
else
	if [ "$1" == "-" ] && [ "$2" != "" ]; then
	PATTERN="$2"
	fi
	V=$(ls -al $OROOT/repo | awk '{print $11}')
	print_ita "REPO" "$OROOT/repo" "$V"	
	while [ $ID -lt $MAX_STEP ] ; do
		prepare_seq_priority "$ID" "$ALL_PACKETS"
		for V in $SORTREQ; do
			V=$(echo $V  | sed -e 's/%/   /g')
			if [ "$PATTERN" == "" ]; then
				PRI=$(echo $V | awk '{print $1}')
				NAME=$(echo $V | awk '{print $2}')"_$ID"
				PRJ=$(echo $V | awk '{print $3}')
				ST=$(getFileSize $BUILD/$PRJ/$NAME/status)
				if [ $ST -eq 0 ]; then 
					ST=1000
				else	
					ST=$( cat $BUILD/$PRJ/$NAME/status)
				fi	
				if [ $ST -lt $STMIN ]; then STMIN=$ST; fi
				ST=$(getStatusString $ST)
				print_ita "STEP : $ID" "$PRI - $ST" "$NAME"
			else
				NAME=$(echo $V | awk '{print $2}')
				if [ "$PATTERN" == "$NAME" ]; then
					PRI=$(echo $V | awk '{print $1}')
					NAME=$(echo $V | awk '{print $2}')"_$ID"
					PRJ=$(echo $V | awk '{print $3}')
					ST=$(getFileSize $BUILD/$PRJ/$NAME/status)
					if [ $ST -eq 0 ]; then 
						ST=1000
					else	
						ST=$( cat $BUILD/$PRJ/$NAME/status)
					fi	
					if [ $ST -lt $STMIN ]; then STMIN=$ST; fi
					ST=$(getStatusString $ST)
					print_ita "STEP : $ID" "$PRI - $ST" "$NAME"
				fi
			fi	
		done
		ID=$((ID+1))
		if [ $ONESTEP -eq 1 ]; then
			break;
		fi
	done
	ST=$(getStatusString $STMIN)
	print_ita "STATUS" "$ST" "$PRJ"
fi
}




#$1 step nn  -> freeze all step -> freeze 1
#$2 optional prj -> freeze a project on sten n -> freeze 1 lzip
#$3 optional pri -> freeze projects with pri < nn ->freeze 1 < 90
function freeze_step(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ID=$1 
local V=""
local PRI=""
local NAME=""
local PRJ=""
local RNAME="$2_$1"
if [ $# -eq 3 ] && [ "$2" != "<" ]; then 
	error_c "bad input" " in case of 3 parameter must be :freeze <step nn> '<' <pri nn_max>"
fi
if [ $# -eq 3 ] && [ "$2" == "<" ]; then
	isNumber $3
	if [ $? -ne 0 ]; then 
	error_c "bad input" " in case of 3 parameter must be :freeze <step nn> '<' <pri nn_max>"
	fi
fi
prepare_seq_priority "$ID" "$ALL_PACKETS" 
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		V=$( getFileSize $BUILD/$PRJ/$NAME/status)
		if [ $V -ne 0 ]; then 
			if [ $# -eq 1 ]; then				
					chmod +w "$BUILD/$PRJ/$NAME/status"
					echo 2 > "$BUILD/$PRJ/$NAME/status"
					chmod -w "$BUILD/$PRJ/$NAME/status"
					print_ita "STEP : $ID" "PRI : $PRI" "$NAME -> set as stable"					
			fi
			if [ $# -eq 2 ] && [  "$NAME" == "$RNAME" ]; then
					chmod +w "$BUILD/$PRJ/$NAME/status"
					echo 2 > "$BUILD/$PRJ/$NAME/status"
					chmod -w "$BUILD/$PRJ/$NAME/status"
					print_ita "STEP : $ID" "PRI : $PRI" "$NAME -> set as stable"
					break
			fi
			if [ $# -eq 3 ] && [  $PRI -lt $3 ]; then
					chmod +w "$BUILD/$PRJ/$NAME/status"
					echo 2 > "$BUILD/$PRJ/$NAME/status"
					chmod -w "$BUILD/$PRJ/$NAME/status"
					print_ita "STEP : $ID" "PRI : $PRI" "$NAME -> set as stable"
			fi
		fi				
	done
}


#$1 step nn 
#$2 optional prj
function hot_step(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ID=$1 
local V=""
local PRI=""
local NAME=""
local PRJ=""
local RNAME="$2_$1"
prepare_seq_priority "$ID" "$ALL_PACKETS" 
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		V=$( getFileSize $BUILD/$PRJ/$NAME/status)
		if [ $V -ne 0 ]; then 
			if [ $# -eq 1 ]; then
				
					chmod +w "$BUILD/$PRJ/$NAME/status"
					echo 0 > "$BUILD/$PRJ/$NAME/status"
					chmod -w "$BUILD/$PRJ/$NAME/status"
					print_ita "STEP : $ID" "PRI : $PRI" "$NAME -> reset to configure"
			fi
			if [ $# -eq 2 ] && [  "$NAME" == "$RNAME" ]; then
					chmod +w "$BUILD/$PRJ/$NAME/status"
					echo 0 > "$BUILD/$PRJ/$NAME/status"
					chmod -w "$BUILD/$PRJ/$NAME/status"
					print_ita "STEP : $ID" "PRI : $PRI" "$NAME -> reset to configure"
					break
			fi
		fi				
	done
}

#$1 optional step
#$2 optional projects
function freeze_build(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local FNUM=0
if [ $# -eq 0 ];  then 
while [ $FNUM -lt $MAX_STEP ] ; do
	freeze_step $FNUM
	FNUM=$((FNUM+1))
done	
else
	freeze_step $1 $2 $3
fi
}


#$1 step
#$2 ...  ARGV
function pri_project(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ID=0
local CMD=""
local START=0
local STOP=0
local OFFSET=0
local V=""
local PRJS=""
local PRI=0
isNumber $1
if [ $? -ne 0 ]; then
	error_c "first input param must be the step number!" "pri <step x> <optional projets>"
fi
ID=$1
shift
CMD=$(echo $1 |  tr '[:lower:]' '[:upper:]')
shift
if [ "$CMD" == "MOVE" ];then
	isNumber $1
	if [ $? -ne 0 ]; then
		error_c "start priority" "$1 missing start priority to move"
	fi
	START=$1
	shift
	isNumber $1
	if [ $? -ne 0 ]; then
		error_c "stop priority" "$1 missing stop priority to move"
	fi
	STOP=$1
	shift
	isNumber $1
	if [ $? -ne 0 ]; then
		error_c "offset priority" "$1 missing offset priority to move"
	fi
	OFFSET=$1
	prepare_seq_priority "$ID" "$ALL_PACKETS"
	for V in $SORTREQ; do
		PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
		PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')	
		MAKE=$(echo -n $V | sed 's/%/ /g' | awk '{print $4}')
		if   [ $PRI -lt $START ]; then
			continue
		fi
		if [ $PRI -ge $START ] && [ $PRI -le $STOP ]; then
			PRI=$((PRI+OFFSET))						
			xmlstarlet ed --inplace -u "/egg/project/build/step[@id=\"$ID\"]/make[@id=\"$MAKE\"]/priority"  -v "$PRI" "$OREPO/$PRJS/conf.egg"			
		fi	
		if [ $PRI -gt $STOP ]; then
			break
		fi
	done
else
	if [ "$CMD" == "SWAP" ];then
	isNumber $1
	if [ $? -ne 0 ]; then
		error_c "start priority" "$1 missing start priority to move"
	fi
	START=$1
	shift
	isNumber $1
	if [ $? -ne 0 ]; then
		error_c "stop priority" "$1 missing stop priority to move"
	fi
	STOP=$1
	if [  $START -ne $STOP ]; then 
		shift
		prepare_seq_priority "$ID" "$ALL_PACKETS"
		for V in $SORTREQ; do
			PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
			PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')	
			MAKE=$(echo -n $V | sed 's/%/ /g' | awk '{print $4}')
			if   [ $PRI -eq $START ]; then
				xmlstarlet ed --inplace -u "/egg/project/build/step[@id=\"$ID\"]/make[@id=\"$MAKE\"]/priority"  -v "$STOP" "$OREPO/$PRJS/conf.egg"
			fi
			if [ $PRI -eq $STOP ]; then
				xmlstarlet ed --inplace -u "/egg/project/build/step[@id=\"$ID\"]/make[@id=\"$MAKE\"]/priority"  -v "$START" "$OREPO/$PRJS/conf.egg"
			fi
		done
	else
		error_c "Input param " "Cannot swap priority of projects" "with the same priority !" "in this case priority " "is from project name"
	fi		
	else	
		if [ "$CMD" == "SPACE" ];then
		isNumber $1
		if [ $? -ne 0 ]; then
			error_c "space priority" "$1 missing space quantity"
		fi
		START=$1
		STOP=0
		shift
			prepare_seq_priority "$ID" "$ALL_PACKETS"
			for V in $SORTREQ; do
				PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
				PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')	
				MAKE=$(echo -n $V | sed 's/%/ /g' | awk '{print $4}')
				xmlstarlet ed --inplace -u "/egg/project/build/step[@id=\"$ID\"]/make[@id=\"$MAKE\"]/priority"  -v "$STOP" "$OREPO/$PRJS/conf.egg"
				STOP=$((STOP+START))
			done
		else
		help_pri
		fi
	fi
fi
}

#$1 optional step
#$2 optional projects
function hot_build(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local FNUM=0
if [ $# -eq 0 ];  then 
while [ $FNUM -lt $MAX_STEP ] ; do
	hot_step $FNUM
	FNUM=$((FNUM+1))
done
	
else
	hot_step $1 $2
fi
}

#$1 new repo to set repo
function set_repo(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local RES=""
RES=$(ls -d $1)
if [ "$RES" ]; then 
	rm -rf $REPO
	rm -f $OROOT/repo
	ln -s $1 $OROOT/repo	
	main list
else
	error_c "setrepo : direcory $1 " "not exist!"
fi	
}


#$1 file with list of repos
function multi_repo(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local PWDM=""
local RES=""
local NUMM=0
local IDM=0
local FILE=""
local PATHS=""
#set -x; trap read debug
if [ $# -ne 1 ]; then
	error_c "multi command  accept only one arg" "input file xml with repos list"
fi 
RES=$(getFileSize $1)
if [ $RES -eq 0 ]; then 
	error_c "multi command  " "input file is empty"
fi
xml_multi_repo_count "$1" "/multi/repo" 
NUMM=$?
while [  $IDM -lt $NUMM ]; do
	FILE=$(xml_multi_repo_value "$1" "/multi/repo[@id=\"$IDM\"]")
	if [ "$FILE" != "" ]; then
		RES=$(ls -d "$FILE")
		if [ "$RES" != "" ]; then 
			RES=$(getFileSize $FILE/conf.egg)
			if [ $RES -ne 0 ]; then
			# ok conf.egg exist
				PATHS=$(ls -d $FILE/*)
				local VV
				for VV in $PATHS; do
					if [ -d $VV ]; then 
						RES=$(getFileSize $VV/conf.egg)
						if [ $RES -eq 0 ]; then
							error_c "multi command  " "File : $VV/conf.egg empty or not exist"
						fi
					fi
				done
			else
				error_c "multi command  " "File : $FILE/conf.egg empty or not exist"
			fi
		else
			error_c "multi command  " "File : $1 repo id=$IDM not is a directory"
		fi
	else
		error_c "multi command  " "File : $1 repo id=$IDM value missing"
	fi
	#ok repo valid
	print_ita "REPO : ID=$IDM" "$FILE" "OK"
	IDM=$((IDM+1))	
done	
warning_c "Multi repo build can start" "For complete build is required many time " "and at the end, only the packets of repo are available" "but all build tree are empty"
print_c "$YELLOW"  "Continue ? [s,n]"
read -r
RES=$(echo $REPLY  | tr '[:lower:]' '[:upper:]')
if [ "$RES" == "S" ]; then 
	IDM=0
	PWDM=$(pwd)
	while [  $IDM -lt $NUMM ]; do
		cd "$PWDM"
		rm -rf $SOURCES
		rm -rf $REPO
		rm -rf $BUILD
		FILE=$(xml_multi_repo_value "$1" "/multi/repo[@id=\"$IDM\"]")
		rm -f $OROOT/repo
		sync
		ln -s $FILE $OROOT/repo
		sync
		main redoall		
		if [ $? -ne 0 ] ; then 
			error_c "multi step " " $FILE FAIL !!";
		fi		
		IDM=$((IDM+1))	
	done
	cd "$PWDM"
	rm -rf $SOURCES
	rm -rf $REPO
	rm -rf $BUILD
	return 0
else
	return 1
fi
}



function usage(){
	print_c "$BLUE_LIGHT" "usage : ./egg <option> command  <args to pass subcommand>"
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "option -D or --debug : set debug mode" 
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "option +W or --warning : print also warnings" 
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "option -B or --break : break and debug function" 
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "option -X or --debug : break and debug functions into" 
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "option -S or --step : debug functions into step by step" 
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "option -T or --test : call direct a function and debug step by step"
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "cat project : print project/conf.egg"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "source : generate bash dwload scripts and dwload all repo sources"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "gen : generate bash build scripts repo projects "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "do : exec configure and build repo projects"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "build : only build no configure repo projects "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "redoall : re - do - all "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "cd <step xx> <project nn> : open a shell of project nn"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "clean <option step xx> <option project nn> : clean "	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "distclean <option step xx> <option project nn> : remove all builds"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "edit <project nn>: edit conf.egg file of project nn"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "reset : remove \$ROOT/build, \$ROOT/image, \$ROOT/repo, \$ROOT/source "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "info : show program info..."
	print_c  "$YELLOW" "COMMAND" "$GREEN" "pack : create a tar of the output "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "multi <file.egg list of repos >: sequence building of projects"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "list : list work repo (... more)"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "setrepo <opt path with new repo> : set a new work repo and list  "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "freeze nn < step number> : set status stable "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "hot nn < step number> : set status to configure "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "clone <src> <new> : clone an existing prj to a new prj"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "pri <step> <....> : move swap project priority"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "help <command>: more info about command and repo"
	print_c  "$PURPLE_LIGHT" "do help <command> for more info"
}



function reset_all(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local VV=""
local ID=0
local LL="$ROOT/build  $ROOT/sources   $ROOT/repo"
local TT=""
warning_c "WARNING : this operation is unrecoverable" "Do You want continue? <y,n>"
read -r ;
VV=$(echo $REPLY  | tr '[:lower:]' '[:upper:]')
if [ "$VV" == "Y" ]
then
	ID=0
	while [ $ID -lt $MAX_STEP ] ; do
		prepare_seq_priority "$ID" "$ALL_PACKETS"
		for V in $SORTREQ; do
			VV=$(echo $V  | sed -e 's/%/   /g')				
			TT=$(echo $VV | awk '{print $3}')
			if [ "$VV" != "$ROOT/images/$TT" ]; then
				VV="$ROOT/images/$TT"				
				if [ -d $VV ]; then
				print_ita " REMOVE : "  "$TT : STEP $ID" "$SIZE"
				rm -rf "$VV"
				fi
			fi					
		done
	ID=$((ID+1))
	done
	for TT in $LL ; do			
		if  [  -d $TT ]
		then					
			local SIZE=$(du -sh $TT | awk '{print $1}')
			print_ita " REMOVE : "  "$TT" "$SIZE"
			rm -rf "$TT"
		else
			print_ita " WARNING : "  "$TT" "not exist"		
		fi	
	done
	if [ -d "$ROOT/store" ]	
	then
		print_ita " .... "  "$ROOT/store" "$(du -sh $ROOT/store| awk '{print $1}')"		
	else
		print_ita " WARNING : "  "$ROOT/store" "not exist"	
		rm -rf $ROOT	
	fi	
	tree $ROOT
fi
}

function default_do(){
        build_all_packet
}


#$1 command to explains
function help_cd(){
help_c "command : cd" \
"\$1 : step number : required " \
"\$2 : project     : optional" \
"if only \$1 is specified open a shell on the build/step_name path" \
"else open a shell on build/step_name/build_step_num" \
"Warning : $PATH is of calling process. to switch on egg env do source setenv.sh" \
"ex : ./egg cd 1 binutils "
}

#$1 command to explains
function help_gen(){
help_c "command : gen" \
"\$1 : step number : optional " \
"\$2... : project-s     : optional" \
"with no param generate all bash scripts for all step and projects" \
"if only \$1 is specified generate all bash scripts for step \$1" \
"else generate all bash scripts for step \$1 project \$2,..\$n" \
"ex : ./egg gen or ./egg gen 1 or" \
"./egg gen 1 binutilis"
}

function help_edit(){
help_c "command : edit" \
"\$1 : name : request " \
"if name = self edit this script" \
"if name = self.conf edit current repo/conf.egg" \
"if name = a name of a project in repo edit repo/name/conf.egg" \
"if name = self.repo edit one by one all repo's conf.egg files" \
"if name = --format format all conf.egg xml files" \
"ex : ./egg edit binutils" \
"the edit is defined in repo/conf.egg/<editor> fields, ex vim"
}


function help_build(){
help_c "command : build" \
"\$1 : step : optional " \
"\$2.. : project-s : optional " \
"with no parameter start build ( ..make nn..) of all step-projects" \
"sequence of build depend from step and pri in conf egg" \
" and go from step=0 and pri 1 to step MAX pri MAX " \
"if \$1 is present build all projects of step \$1" \
"if \$2 or more input build projects \$2...\$n of step \$1" \
"ex ./egg build 0"
}


function help_reset(){
help_c "command : reset" \
"Clean all build and sources paths" \
"ex ./egg reset"
}

function help_clean(){
help_c "command : clean" \
"\$1 : step : optional " \
"\$2.. : project-s : optional " \
"with no parameter start clean of all step-projects" \
"sequence of clean depend from step and pri in conf egg" \
" and go from step=0 and pri 1 to step MAX pri MAX " \
"if \$1 is present clean all projects of step \$1" \
"if \$2 or more input clean projects \$2...\$n of step \$1" \
"ex ./egg clean 0"
}

function help_multi(){
help_c "command : multi" \
"\$1 : file : request " \
"the file must content a list of repos path" \
"execute for all repos in list reset + redoall" \
"ex ./egg multi list.egg 0"
}

function help_distclean(){
help_c "command : distclean" \
"\$1 : step : optional " \
"\$2.. : project-s : optional " \
"with no parameter start distclean (rm build path )of all step-projects" \
"sequence of distclean depend from step and pri in conf egg" \
" and go from step=0 and pri 1 to step MAX pri MAX " \
"if \$1 is present distclean all projects of step \$1" \
"if \$2 or more input distclean projects \$2...\$n of step \$1" \
"ex ./egg distclean 0 binutils"
}


function help_do(){
help_c "command : do" \
"\$1 : step : optional " \
"\$2.. : project-s : optional " \
"with no parameter start d0 (configure + build )of all step-projects" \
"sequence of do depend from step and pri in conf egg" \
" and go from step=0 and pri 1 to step MAX pri MAX " \
"if \$1 is present do all projects of step \$1" \
"if \$2 or more input do projects \$2...\$n of step \$1" \
"ex ./egg do 0 binutils"
}

function help_redoall(){
help_c "command : redoall" \
"execute for all step-projects source+distclean+do  " \
"ex ./egg redoall"
}

function help_pack(){
help_c "command : pack" \
"if all repo is 'stable' (all build successfull ended and install ok)"  \
"the \$DEPLOY path was compressed by tar and all build " \
"directory was cleaned" \
"note : after a redoall/do/build in case of success " \
"pack is auto called " \
"ex ./egg pack"
}

function help_list(){
help_c "command : list" \
"\$1 ,\$2,\$3: optional " \
"mode 1 : list all repo projects in build ordered sequence" \
"mode 1 : list <\$1=step NN> list only step NN repo projects" \
"mode 1 : list <\$1='-'>  <\$2=name> find if name projects is in repo" \
"mode 1 : list <\$1=step NN > <\$2='-'> <\$3=name> find only in step NN" \
"mode 2 : if \$1 not in repo projects name , check if is in env and " \
"if \$1 is present do tree -L 1 \$1" \
"ex ./egg list 1 or ./egg list IMAGES"
}

function help_setrepo(){
help_c "command : setrepo" \
"\$1 : file : optional  " \
"set file to current repo (set repo lnk in eggX folder to file)" \
"and call list" \
"ex ./egg setrepo x86_64_toolkit_repo"
}

function help_freeze(){
help_c "command : freeze" \
"if untar previus file of \$DEPLOY dir and do not want rebuild" \
"the relative repo You can do freeze and set all projects flags" \
"to stable and freeze all build commands"   \
"ex ./egg freeze"
}


function help_hot(){
help_c "command : hot" \
"set project<s> to configure :  to enable rebuild of a project " \
"previous declared as stable" \
"ex ./egg hot"
}

function help_source(){
help_c "command : source" \
"source download or check the source of projects" \
"ex ./egg source"
}

function help_cat(){
help_c "command : cat " \
"cat of conf.egg projects" \
"\$1 : project name " \
" ex. cat binutils"
}

function help_clone(){
help_c "command : source" \
"\$1 : source project to clone"\
"\$2 : new project"\
"clone an existing project to a new project" \
"ex ./egg source"
}


#$1 command to explains
function help_pri(){
help_c "command : pri manage projects priority" \
"\$1 : step number " \
"\$2... : argv" \
"if \$2=move -> start stop offset" \
"if \$2=swap -> src dest " \
"./egg pri 1 mode 25 30 5" \
"./egg pri 1 swap 25 30 " 
}

function help_options(){
help_c "command : before any command you can set an option" \
"option -D or --debug : set debug mode"  \
"option -S or --step :execute step by step script" \
"option +W or --verbose : show more warning" \
"option -B <function> or --break : break and set debug at function " \
"option -X <function> or --deepbreak : break and set debug at function (into) " \
"option -T <function> or --test : break and set debug and call function " \
"ex ./egg -S build"
}

function help_command(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1		
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local OK=0
local -a COMMANDS=('source' 'cd' 'gen' 'edit' 'build' 'reset' \
					'clean' 'multi' 'distclean' 'do' 'redoall' \
					'pack' 'list' 'setrepo' 'freeze' \
					'hot' 'clone' 'cat' 'pri' 'options')
local VV=""
local torun=""
if [ $# -eq 0 ]; then
	warning_c "missing argument" "help command require an argument!" " ex ./egg help do" "show all command help <y,n>"
	read -r ;
	VV=$(echo $REPLY  | tr '[:lower:]' '[:upper:]')
	if [ "$VV" == "Y" ]
	then
		for VV in ${COMMANDS[@]} ; do 
				torun="help_$VV"
				"$torun"		
				OK=1	
		done
	fi
else
	for VV in ${COMMANDS[@]} ; do 
		if [ "$VV" == "$1" ]; then 
			torun="help_$VV"
			"$torun"
			OK=1
			break
		fi		
	done
fi

if [ $OK -eq 0 ]; then
	help_c "Available help commands:" \
	"${COMMANDS[0]} ${COMMANDS[1]} ${COMMANDS[2]} ${COMMANDS[3]}" \
	"${COMMANDS[4]} ${COMMANDS[5]} ${COMMANDS[6]} ${COMMANDS[7]}" \
	"${COMMANDS[8]} ${COMMANDS[9]} ${COMMANDS[10]} ${COMMANDS[11]}" \
	"${COMMANDS[12]} ${COMMANDS[13]} ${COMMANDS[14]} ${COMMANDS[15]}" \
	"${COMMANDS[16]} ${COMMANDS[17]} ${COMMANDS[18]} ${COMMANDS[19]}" \
	"${COMMANDS[20]}"	
fi

}





function legal(){
local VV=$(ps -a | grep egg | awk '{print $4}')
local II=${#VV[@]}
if [ $II -eq 1 ]; then 
print_c "$WHITE" "Copyright (C) 2017 Angelo Coppi. <angelogkcop@hotmail.com>"
print_c "$GREEN" "This is free software; see the LICENSE file for copying conditions."
print_c "$GREEN" "There is NO warranty; not even for MERCHANTABILITY or FITNESS "
print_c "$GREEN" "FOR A PARTICULAR PURPOSE."
fi
}


function iterative(){
ITERATIVE=1
local LINE=""
local VV=$( ls -al repo | awk '{ print $11 }' )
print_c "$WHITE" "Current repo : " "$YELLOW" "$VV"
print_c "$GREEN" "quit/exit for exit iterative mode"

echo -n -e $(echo $CYAN) "egg"$(echo $BLUE) "> "$(echo $REPLACE) 
while IFS="" read  -r -e -d $'\n'  LINE; do 
history -s "$LINE"
if [ "$LINE" == "quit" ] || [ "$LINE" == "exit" ]; then
	break;
fi
if [ "$LINE" != "" ]; then 
	./egg   $LINE
else
	usage
fi
echo -n -e $(echo $CYAN) "egg"$(echo $BLUE) "> "$(echo $REPLACE) 
done
ITERATIVE=0
}

#$1 src project
#$2 dest project
function clone_project(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1		
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local VV
local ALL=$( ls  $OREPO | sed -e 's/conf.egg//g')
if [ "$1" != "" ]; then 
	VV=$(echo $ALL | grep "\<$1\>")
	if [ "$VV" == "" ]; then 
		error_c "Not Found" "$1 not found in this repo"
	fi
fi

if [ "$2" != "" ]; then 
	VV=$(echo $ALL | grep "\<$2\>" )
	if [ "$VV" != "" ]; then 
		error_c "Already exist" "$2 : already exist in this repo"
	fi
fi
#ok copy src to dest
mkdir -p "$OREPO/$2"
cp "$OREPO/$1/conf.egg" "$OREPO/$2/."
if [ $? -ne 0 ]; then 
	error_c "Fail on copy" "cannot copy $OREPO/$1/conf.egg" "$OREPO/$1/."
fi	
xmlstarlet  ed --inplace -u "/egg/project/name" -v "$2" "$OREPO/$2/conf.egg"
xmlstarlet  ed --inplace -u "/egg/project/remote/url" -v "  " "$OREPO/$2/conf.egg"
xmlstarlet  ed --inplace -u "/egg/project/remote/file" -v "  " "$OREPO/$2/conf.egg"
./egg edit "$2"
}


function search_all_packet(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1		
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local ALL=$(ls -d $OROOT/repo/* )
local VV=""
ALL_PACKETS=""
for VV in $ALL; do
	if  [ -d "$VV" ]; then 
		ALL_PACKETS+=" $(basename $VV )"
	fi
done 
}



function man_select_repo(){
if [ $BREAK_BREAK -ne 0 ] && [ "${FUNCNAME[0]}" == "$BREAK_FUNCTION" ]; then
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	[ $BREAK_DEEP -ne 0 ] && STEP_STEP=1		
	print_ita "ARGV :" "NUM:$#" "$1 $2 $3 $4 $5 $6 $7 $8 $9"
	set -x ; trap read debug 	
fi
[ $STEP_STEP -eq 1 ] && trap read debug
local LS=$(ls $OROOT)
local VV=""
local ID=1
local RES=0
local -a DIRS=""
warning_c "No repo set " "Please select one from the following repository"
for VV in $LS; do
	if [  -d "$OROOT/$VV" ] && [ -f "$OROOT/$VV/conf.egg" ]; then 
		print_c "$CYAN" "$ID) - " "$WHITE" "$VV"
		DIRS[$ID]=$VV
		ID=$((ID+1))
	fi
done 
while [ 1 -eq 1 ] ; do
read -r
RES=$(echo $REPLY )
if [ $RES -gt 0 ] && [ $RES -lt $ID ]; then 
      rm -rf "$OROOT/repo"
      ln -s "$OROOT/${DIRS[$RES]}" "$OROOT/repo" 	
     break
else
	print_c "$RED" "Invalid selection!"
fi

done 
}

#$1 build id number
function main(){
local torun=default_do
#non zero more verbose warning
MOREWRN=0
#non zero step by step debug from start
STEP_STEP=0
#non zero a function breakpoint enable
BREAK_BREAK=0
#non zero set  STEP_STEP to 1 to debug into 
BREAK_DEEP=0
#start debug a function name $BREAK_FUNCTION
BREAK_FUNCTION=""

while [ $# -ne 0 ]; do
case $1 in 
	-S|--step)
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	STEP_STEP=1
	set -x ; trap read debug
	shift
	;;
	-D|--debug)
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	set -x
	shift
	;;	
	+W|--verbose)
	MOREWRN=1
	shift
	;;
	-B|--break)
	BREAK_BREAK=1
	BREAK_DEEP=0	
	shift
	BREAK_FUNCTION=$1
	if [ "$BREAK_FUNCTION" == "" ] ; then
		error_c "On set function breakpoint" "missing function name!"
	fi
	shift
	warning_c "Set debug breakpoint" "At function $BREAK_FUNCTION"
	;;
	-X|--deepbreak)
	BREAK_BREAK=1
	BREAK_DEEP=1	
	shift
	BREAK_FUNCTION=$1
	if [ "$BREAK_FUNCTION" == "" ] ; then
		error_c "On set function breakpoint" "missing function name!"
	fi
	shift
	warning_c "Set debug breakpoint" "At function $BREAK_FUNCTION"
	;;
	-T|--test)
	BREAK_BREAK=1
	BREAK_DEEP=0	
	shift
	BREAK_FUNCTION=$1
	if [ "$BREAK_FUNCTION" == "" ] ; then
		error_c "On set function breakpoint" "missing function name!"
	fi
	shift
	warning_c "Set debug breakpoint" "At function $BREAK_FUNCTION"
	torun="$BREAK_FUNCTION"
	break
	;;
	cat)
	torun=cat_project
	shift
	break
	;;	
	source)
	torun=source_download
	shift
	break
	;;
	cd)
	torun=shell_packet
	shift
	break
	;;	
	gen)
	torun=config_all_step
	shift
	break
	;;	
	edit)
	torun=edit_packet
	shift
	break
	;;	
	build)
	torun=compile_all_packet
	shift
	break
	;;
	reset)
	torun=reset_all
	shift
	break
	;;	
	clean)
	torun=clean_all_packet
	shift
	break
	;;
	multi)
	torun=multi_repo
	shift
	break
	;;		
	distclean)
	torun=distclean_all_packet
	shift
	break
	;;	
	do)
	torun=build_all_packet
	shift
	break
	;;		
	redoall)
	torun=redoall		
	shift
	break
	;;	
	info)
	torun=show_info		
	break
	;;	
	pack)
	torun=packetize_all		
	break
	;;	
	list)
	shift
	torun=list 		
	break
	;;	
	setrepo)
	torun=set_repo		
	shift
	break
	;;
	freeze)
	torun=freeze_build		
	shift
	break
	;;
	hot)
	torun=hot_build		
	shift
	break
	;;
	clone)
	torun=clone_project		
	shift
	break
	;;
	pri)
	torun=pri_project		
	shift
	break
	;;
	help)
	torun=help_command		
	shift
	break
	;;	
	*)	
	usage
	error_c "Command line" " unknow  $1"
	;;
esac
 done

#set log to download
if [ ! -d $ROOT ]; then 
	mkdir -p $ROOT
fi

if [ -d  $OREPO ]; then 
# sync repo file to build path 
rsync -ry $OREPO $REPO
else
    man_select_repo
    rsync -ry $OREPO $REPO
fi

xml_get_env 

#set log to download
if [ ! -d $STORE ]; then 
	mkdir -p $STORE
fi

if [ ! -d $IMAGES ]; then 
	mkdir -p $IMAGES
fi

if [ ! -d $BUILD ]; then 
	mkdir -p $BUILD
fi

if [ ! -d $SOURCES ]; then 
	mkdir -p $SOURCES
fi

#sort project in repo to bin search

search_all_packet

unset MAP
declare -A MAP    

for key in $ALL_PACKETS; do MAP[$key]="$key"; done  

if [ $? -ne 0 ]; then
	error_c "Cannot  sync work repository"
fi

get_max_step

"$torun" "$@"
}


EGG_RES=0
EGG_START_TIME=$(date  +%s)
legal
if [ $# -eq 0 ] ; then		
	iterative
else
	main "$@"
fi
EGG_RES=$?
EGG_STOP_TIME=$(date  +%s)
EGG_TOTAL_TIME=$((EGG_STOP_TIME-EGG_START_TIME))
print_c "$PURPLE" " -- " "$YELLOW " $EGG_TOTAL_TIME "$WHITE" " sec"
exit $EGG_RES
