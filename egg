#!/bin/sh 

# where is the project eggX
export OROOT="$HOME/eggX"

SCRIPT_DIR=$OROOT/scripts
OREPO=$OROOT/repo/.

# eggX working path default before read general conf.egg
ROOT="$HOME/ebuild"
REPO="$ROOT/repo"
SOURCES="$ROOT/sources"
IMAGES="$ROOT/images"
REPOBACKUP="$ROOT/backup"
BUILD="$ROOT/build"
EDITOR="vim"
CPATH=""
C_INCLUDE_PATH=""
CPLUS_INCLUDE_PATH=""
HW_ARCH=""
# include io functions
source "$SCRIPT_DIR/functions.sh"


   
declare -A SORTREQ


declare -i MAX_STEP=0


function forcestop(){
	error_c "User Interrupt" " warning work not complete! "
}

trap "forcestop" SIGHUP SIGINT SIGTERM

# test if exist project <name> from packets list...
# $1 packet name
function check_project(){
local tmp=""
if [[ -n "${MAP[$1]}" ]]; then
	return 1
fi
return 0
}


#$1 project
#$2 build phase number 0,1,2.....
function insert_packet(){
local PRI=""
local NAME=""
local INDEX=""
local NUM=0
local ID=0
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					ID=0
					while [  $ID -lt $NUM ]; do
						PRI=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$ID\"]/priority")		
						equs "$PRI"  
						if [ $? -eq 1 ]; then 
							error_c "Missing  build make id=$ID priority Phase $2" "project : $1"
						fi
						NAME=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/name")		
						equs "$NAME"  
						if [ $? -eq 1 ]; then 
							error_c "Missing  build name Phase $2" "project : $1"
						fi 
						INDEX="$PRI%$1%$NAME"
						BSEQ[$INDEX]="$INDEX"	
					ID=$((ID+1))	
					done	
				fi	
			fi	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}

#$1 ID BUILD STEP
function prepare_seq_priority(){
local V=""
unset BSEQ
declare -A BSEQ
for V in $ALL_PACKETS; do
	insert_packet $V $1
done	
SORTREQ=$(echo ${BSEQ[*]}| tr " " "\n" | sort -n )
}

#set numero massimo di step a disposizone
function get_max_step(){
MAX_STEP=$(xmlstarlet sel -t  -v "count(/egg/defaults/step)" -n $REPO/conf.egg)
}

# $1 project
# $2 string array prj names
function check_prj_name(){
local NAME=""
local TT=""
local PRJ_NAME=$2
declare -i IND=0
	xml_count $1 "/egg/project/build"
	IND=$?
	if [ $IND -eq 1 ]; then
		IND=0
		while [  $IND -lt $MAX_STEP ]; do
		NAME=$(xml_value $1 "/egg/project/build/step[@id='$IND']/name")		
		equs "$NAME"  
		if [ $? -eq 0 ]
		then 
			TT=$(echo $PRJ_NAME | grep $NAME)
			if [ "$TT" == "" ]; then 
				PRJ_NAME="$PRJ_NAME""  ""$NAME"
			fi
		fi 	
		IND=$((IND+1))		
		done
	fi
echo $PRJ_NAME
}


#print build start 
#$1 pririty
#$2 name
#$3 project
function print_build_msg(){
print_ita  "BUILD : $1"  "$2"  "$3"
}

#print build start 
#$1 pririty
#$2 name
#$3 project
function print_conf_msg(){
print_ita  "CONF  : $1"  "$2"  "$3"
} 

#print build start 
#$1 pririty
#$2 name
#$3 project
function print_clean_msg(){
print_ita  "CLEAN : $1"  "$2"  "$3"
}


#none
function build_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_conf_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/bootstrap.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			print_build_msg "$PRI" "$NAME" "$PRJ"
			"$BUILD/$PRJ/$NAME/build_$PRI.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			sync
		fi	
	done
	ID=$((ID+1))
done
packetize_all
}


#none
function packetize_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
local STATUS=0
local RESULT=0
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [[ $(getFileSize "$BUILD/$PRJ/$NAME/status") != "0" ]]; then
			STATUS=$(cat "$BUILD/$PRJ/$NAME/status")
			if [ $STATUS -ne 2 ]; then
				RESULT=1
				break
			fi
		fi
	done
	ID=$((ID+1))
done
if [ $RESULT -eq 0 ]; then 	
	local PWD=$(pwd)
	start_time=$(date +%s)
	print_ita "PKT" "$PRJ" "..." 
	V=$(getFileSize $IMAGES/$PRJ.tar.bz2)
	if [  $V -ne 0  ]; then  
		rm -f $IMAGES/$PRJ.tar.bz2 
		rm -f $IMAGES/$PRJ.tar.bz2.md5
	fi
	cd "$IMAGES/$PRJ"
	tar -cjSf $IMAGES/$PRJ.tar.bz2   .
	md5sum $IMAGES/$PRJ.tar.bz2 > $IMAGES/$PRJ.tar.bz2.md5
	cd $PWD
	ID=0;
	while [ $ID -lt $MAX_STEP ] ; do
		prepare_seq_priority $ID
		for V in $SORTREQ; do
			V=$(echo $V  | sed -e 's/%/   /g')
			PRI=$(echo $V | awk '{print $1}')
			NAME=$(echo $V | awk '{print $2}')"_$ID"
			PRJ=$(echo $V | awk '{print $3}')
			rm -rf $BUILD/$PRJ/$NAME/build
			rm -rf $BUILD/$PRJ/$NAME/*.log
			mkdir -p $BUILD/$PRJ/$NAME/build
		done
		ID=$((ID+1))
	done
	stop_time=$(date +%s)
	total_time=$((stop_time-start_time))
	print_ita "$PRJ.tar.bz2"  "$(getFileSize $IMAGES/$PRJ.tar.bz2 ) Bytes"  "$total_time sec"
else
	error_c "$PRJ contain packeges not in ready to packetize " "project : $NAME" 
fi
print_del_ita
}

#none
function compile_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
#set -x ; trap read debug
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_build_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/build_$PRI.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
		fi
	done
	ID=$((ID+1))
done
packetize_all
}

#none
function clean_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_clean_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/clean.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
		fi
	done
	ID=$((ID+1))
done
}

#none
function distclean_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_clean_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/distclean.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
		fi
	done
	ID=$((ID+1))
done
}

#$1 function to execute
#$2 ID step build
#$3 ... SN projects
#$@ from argv build.sh
function exec_single(){
#trovo nomi build per ogni progetto
local ID=0
local PRJ_NAMES=""
local PRI=""
local NAME=""
local PRJ=""
local SEQ=""
local FUNCTION=""
if [ ! "$1" ]; then
	error_c "Input missing function to execute  !!"
fi
FUNCTION="$1  "
isNumber $2
if [ $? -ne 0 ]; then
   error_c "$2 : Input step isn't a number !!"
fi
ID=$2
if [ ! "$3" ]; then
	error_c "Input missing project  !!"
fi
shift
shift
# set -x ; trap read debug

for V in $@; do
	PRJ_NAMES=$(check_prj_name "$V" "$PRJ_NAMES")
done
local PWD=$(pwd)
prepare_seq_priority $ID
for V in $PRJ_NAMES; do
	for I in $@; do
		for T in $SORTREQ; do
			SEQ=$(echo $T | grep $V | grep $I )
				if [ "$SEQ" != "" ]; then 
					break;
				fi
		done
		SEQ=$(echo $SEQ  | sed -e 's/%/   /g')
		PRI=$(echo $SEQ | awk '{print $1}')
		NAME=$(echo $SEQ | awk '{print $2}')"_$ID"
		PRJ=$(echo $SEQ | awk '{print $3}')
		if [ -d "$BUILD/$V/$NAME" ]; then
			$FUNCTION   "$PRI" "$NAME" "$PRJ" "$BUILD/$V/$NAME"
		fi
	done 
done
}

function exec_build(){
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_build_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/clean.sh"
"$PATH/bootstrap.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
"$PATH/build_$PRI.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
}

#$@ from argv build.sh
function build_single(){
local ARGV="$@"
exec_single "exec_build" $ARGV
}

function exec_compile(){
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_build_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/build_$PRI.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
}

#$@ from argv build.sh
function compile_single(){
local ARGV="$@"
exec_single "exec_compile" $ARGV
}


function exec_clean(){
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_clean_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/clean.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
}

#$@ from argv build.sh
function clean_single(){
local ARGV="$@"
exec_single "exec_clean" $ARGV
}

function exec_distclean(){
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_clean_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/distclean.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
}

#$@ from argv build.sh
function distclean_single(){
local ARGV="$@"
exec_single "exec_distclean" $ARGV
}


#$@
function build_all_packet(){
if [ "$1" == "" ]; then
	build_all
else
	build_single $@
fi
print_del_ita
}

#$@
function compile_all_packet(){
if [ "$1" == "" ]; then
	compile_all
else
	compile_single $@
fi
print_del_ita
}

#$@
function clean_all_packet(){
if [ "$1" == "" ]; then
	clean_all
else
	clean_single $@
fi
print_del_ita
}

#$@
function distclean_all_packet(){
if [ "$1" == "" ]; then
	distclean_all
else
	distclean_single $@
fi
print_del_ita
}



#$ARGV TODO
function config_all_step(){
declare -i NUM=0
if [ $# -eq 0 ]; then
	while [ $NUM -lt $MAX_STEP ]; do 
		$SCRIPT_DIR/configure.sh  $NUM $@
		if [ $? -ne 0 ]; then 
			exit 1
		fi
		NUM=$((NUM+1))
	done
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		NUM=$1
		shift
		$SCRIPT_DIR/configure.sh $NUM $@
		if [ $? -ne 0 ]; then 
			exit 1
		fi
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi
print_del_ita
}



#$ARGV 
# ex 0 gcc -> try step of project gcc
function shell_packet(){
local PRJ=""
local V=""
local i=""
local NUM=$1
isNumber $1
if [ $? -ne 0 ]; then
   error_c "$1 : Input step isn't a number !!"
fi
if [ ! "$2" ]; then
	if [ $NUM -lt $MAX_STEP ]; then
		prepare_seq_priority $NUM
		if [ "$SORTREQ" == "" ]; then
			error_c "Step $1 for project $2 not configured!" "project : $2"
		fi
		PRJ=${SORTREQ[0]}
		V=$(echo $PRJ  | sed -e 's/%/   /g')
		NAME=$( echo $V | awk '{print $3}' )
		if [ "$NAME" == "" ]; then			
				error_c "Step $1 unknown name!" "project : $2"
		fi
		print_c "$GREEN_LIGHT" "execute cd : $BUILD/$NAME"
		print_c "$GREEN_LIGHT" "do exit to return..."
		cp $HOME/.bashrc /tmp/egg_shellrc
		echo "cd $BUILD/$NAME" >> /tmp/egg_shellrc
		bash --noprofile --rcfile /tmp/egg_shellrc
	else
		error_c "Input step too BIG !!"
	fi	
else
	if [ $NUM -lt $MAX_STEP ]; then
		prepare_seq_priority $NUM
		if [ "$SORTREQ" == "" ]; then
			error_c "Step $1 for project $2 not configured!" "project : $2"
		fi
		for PRJ in $SORTREQ; do
			V=$(echo $PRJ  | sed -e 's/%/   /g')
			NAME=$( echo $V | awk '{print $2}' )
			if [ "$NAME" == "$2" ]; then			
				PRJ=$( echo $V | awk '{print $3}' )
				break;
			fi
		done
		if [ $PRJ ]; then
		#V=$(pwd)
		print_c "$GREEN_LIGHT" "execute cd : $BUILD/$PRJ/$2_$1"
		print_c "$GREEN_LIGHT" "do exit to return..."
		print_c "$GREEN_LIGHT" "do source ./setenv.sh to enter in build environment"
		cp $HOME/.bashrc /tmp/egg_shellrc
		echo "cd $BUILD/$PRJ/$2_$1" >> /tmp/egg_shellrc
		bash --noprofile --rcfile /tmp/egg_shellrc 
		#cd $V	
		set +x
		fi
	else
		error_c "Input step too BIG !!"
	fi
fi
}

#recussive edit on repo project
function edit_repo_files(){
local ALL_FILES=$(ls "$OREPO")
local VV=""
#cp "$OREPO/conf.egg" "$OREPO/conf.egg_$(date +%d-%m-%y_%H:%M:%S).backup"
$EDITOR "$OREPO/conf.egg"
for VV in $ALL_FILES;  do
if [ "$VV" == "." ]; then continue; fi
if [ "$VV" == ".." ]; then continue; fi
if [ -d "$OREPO/$VV" ]; then 
	cp "$OREPO/$VV/conf.egg" "$OREPO/$VV/conf.egg_$(date +%d-%m-%y_%H:%M:%S).backup"
	$EDITOR "$OREPO/$VV/conf.egg" 
fi
done
}


#$ARGV 
#  gcc -> edit conf.egg of project gcc
function edit_packet(){
local PRJ=""
local V=""
if [ ! "$1" ]; then
	error_c "Missing Input project "
fi
check_project "$1"
if [ $? -ne 0 ]; then
	$EDITOR "$OREPO/$1/conf.egg" > /dev/null  &
else
		if [ "$1" == "self" ]; then
				$EDITOR "egg" > /dev/null  &
		else
			case $1 in
				self.conf)
				$EDITOR "$OREPO/conf.egg" > /dev/null  &
				;;
				self.configure)
				$EDITOR "$SCRIPT_DIR/configure.sh" > /dev/null  &
				;;
				self.source)
				$EDITOR "$SCRIPT_DIR/sources.sh" > /dev/null  &
				;;
				self.functions)
				$EDITOR "$SCRIPT_DIR/functions.sh"  > /dev/null  &
				;;
				self.repo)
				edit_repo_files
				;;
				*)
				error_c "Missing project in $OREPO " "project : $1"
				;;
			esac	
		fi
fi
}

function show_info(){
print_ita "author" "Angelo" "Coppi"
print_ita "email" "angelogkcop@" "hotmail.com"
print_ita "git" "https://github.com" "ataima"
exit 0
}


#$ARGV
function redoall(){
$SCRIPT_DIR/sources.sh
	if [ $? -ne 0 ]; then 
		exit 1
	fi
	config_all_step
	build_all_packet
}

#$1 file with list of repos
function multi_repo(){
local PWDM=""
local RES=""
local NUMM=0
local IDM=0
local FILE=""
local PATHS=""
#set -x; trap read debug
if [ $# -ne 1 ]; then
	error_c "multi command  accept only one arg" "input file xml with repos list"
fi 
RES=$(getFileSize $1)
if [ $RES -eq 0 ]; then 
	error_c "multi command  " "input file is empty"
fi
xml_multi_repo_count "$1" "/multi/repo" 
NUMM=$?
while [  $IDM -lt $NUMM ]; do
	FILE=$(xml_multi_repo_value "$1" "/multi/repo[@id=\"$IDM\"]")
	if [ "$FILE" != "" ]; then
		RES=$(ls -d "$FILE")
		if [ "$RES" != "" ]; then 
			RES=$(getFileSize $FILE/conf.egg)
			if [ $RES -ne 0 ]; then
			# ok conf.egg exist
				PATHS=$(ls -d $FILE/*)
				local VV
				for VV in $PATHS; do
					if [ -d $VV ]; then 
						RES=$(getFileSize $VV/conf.egg)
						if [ $RES -eq 0 ]; then
							error_c "multi command  " "File : $VV/conf.egg empty or not exist"
						fi
					fi
				done
			else
				error_c "multi command  " "File : $FILE/conf.egg empty or not exist"
			fi
		else
			error_c "multi command  " "File : $1 repo id=$IDM not is a directory"
		fi
	else
		error_c "multi command  " "File : $1 repo id=$IDM value missing"
	fi
	#ok repo valid
	print_ita "REPO : ID=$IDM" "$FILE" "OK"
	IDM=$((IDM+1))	
done	
print_c "$YELLOW"  "Continue ? [s,n]"
read -r
RES=$(echo $REPLY  | tr '[:lower:]' '[:upper:]')
if [ "$RES" == "S" ]; then 
	IDM=0
	PWDM=$(pwd)
	while [  $IDM -lt $NUMM ]; do
		cd "$PWDM"
		rm -rf $SOURCES
		sync
		rm -rf $REPO
		sync
		rm -rf $BUILD
		sync
		FILE=$(xml_multi_repo_value "$1" "/multi/repo[@id=\"$IDM\"]")
		rm -f $OROOT/repo
		sync
		ln -s $FILE $OROOT/repo
		sync
		main redoall		
		if [ $? -ne 0 ] ; then 
		exit 1
		fi		
		IDM=$((IDM+1))	
	done
fi
}



function usage(){
	print_c "$BLUE_LIGHT" "usage : ./build.sh <-D> command  <args to pass subcommand>"
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "-D or --debug : set debug mode" 
	print_c  "$YELLOW" "COMMAND" "$GREEN" "source : download all sources from repo projects"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "configure : configure all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "do : configure+build    all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "build :   build all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "redoall : clear all build and deploy  and redo source + configure+do"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "shell <step xx> <project nn>: open a shell with setenv for step xx of project nn"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "clean <option step xx> <option project nn>: clean all, clean all step, clean all step:project"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "distclean <option step xx> <option project nn>: remove build dir for all, all step,  step:project"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "edit <project nn>: edit a conf.egg file of project nn"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "reset : remove working path: $ROOT/build, $ROOT/image, $ROOT/repo, $ROOT/source "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "info : show program info..."
	print_c  "$YELLOW" "COMMAND" "$GREEN" "packetize : create a tar of the output "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "multi <file.egg list of repos >: sequence building of project in list "
	exit 1
}

function reset_all(){
	local VV=""
	warning_c "WARNING : this operation is unrecoverable" "Do You want continue? <y,n>"
	read -r ;
	VV=$(echo $REPLY  | tr '[:lower:]' '[:upper:]')
	if [ "$VV" == "Y" ]
	then
		local LL="$ROOT/build  $ROOT/source  $ROOT/images $ROOT/repo"
		local TT=""
		for TT in $LL
			do			
				if  [  -d $TT ]
				then					
					local SIZE=$(du -sh $TT | awk '{print $1}')
					print_ita " REMOVE : "  "$TT" "$SIZE"
					rm -rf "$TT"
				else
					print_ita " WARNING : "  "$TT" "not exist"		
				fi	
			done
		if [ -d "$ROOT/store" ]	
		then
			print_ita " .... "  "$ROOT/store" "$(du -sh $ROOT/store| awk '{print $1}')"		
		else
			print_ita " WARNING : "  "$ROOT/store" "not exist"	
			rm -rf $ROOT	
		fi	
	fi
}


function default_do(){
        build_all_packet
}


#$1 build id number
function main(){
local torun=default_do
if [ $# -ne 0 ]; then
for i in $@; do
case $i in 
	-D|--debug)
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	set -x
	shift
	;;	
	source)
	torun=$SCRIPT_DIR/sources.sh
	shift
	break
	;;
	shell)
	torun=shell_packet
	shift
	break
	;;	
	configure)
	torun=config_all_step
	shift
	break
	;;	
	edit)
	torun=edit_packet
	shift
	break
	;;	
	build)
	torun=compile_all_packet
	shift
	break
	;;
	reset)
	torun=reset_all
	shift
	break
	;;	
	clean)
	torun=clean_all_packet
	shift
	break
	;;
	multi)
	torun=multi_repo
	shift
	break
	;;		
	distclean)
	torun=distclean_all_packet
	shift
	break
	;;	
	do)
	torun=build_all_packet
	shift
	break
	;;		
	redoall)
	torun=redoall		
	shift
	break
	;;	
	info)
	torun=show_info		
	break
	;;	
	packetize)
	torun=packetize_all		
	break
	;;	
	*)
	usage
	error_c "Command line" " unknow option $i"
	;;
esac
done

fi




#set log to download
if [ ! -d $ROOT ]; then 
	mkdir -p $ROOT
fi

# sync repo file to build path 
rsync -ry $OREPO $REPO

xml_get_env 




#sort project in repo to bin search
ALL_PACKETS=$(ls $OROOT/repo  | sed 's/conf.egg//g')

unset MAP
declare -A MAP    

for key in $ALL_PACKETS; do MAP[$key]="$key"; done  

if [ $? -ne 0 ]; then
	error_c "Cannot  sync work repository"
fi


get_max_step
"$torun" "$@"
}

function legal(){
print_c "$WHITE" "Copyright (C) 2017 Angelo Coppi. <angelogkcop@hotmail.com>"
print_c "$GREEN" "This is free software; see the LICENSE file for copying conditions."
print_c "$GREEN" "There is NO warranty; not even for MERCHANTABILITY or FITNESS "
print_c "$GREEN" "FOR A PARTICULAR PURPOSE."
}


legal
main "$@"
