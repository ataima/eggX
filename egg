#!/bin/sh  

if [ "$OROOT" == "" ] ; then
	OROOT="$HOME/eggX"
fi

SCRIPT_DIR=$OROOT/scripts
OREPO=$OROOT/repo/.

# eggX working path default before read general conf.egg
ROOT="$HOME/ebuild"
REPO="$ROOT/repo"
SOURCES="$ROOT/sources"
IMAGES="$ROOT/images"
REPOBACKUP="$ROOT/backup"
BUILD="$ROOT/build"
EDITOR="vim"
#initial value PATH
START_PATH="/usr/bin:/sbin:/bin"
MYPATH=""
CPATH=""
C_INCLUDE_PATH=""
CPLUS_INCLUDE_PATH=""
ARCH=""
CROSS=""
CC=""
CXX=""
AS=""
LD=""
NM=""
AR=""
STRIP=""
HW_ARCH=""
# include io functions
source "$SCRIPT_DIR/functions.sh"


declare -i NOPKT=0
   
declare -A SORTREQ


declare -i MAX_STEP=0


function forcestop(){
	error_c "User Interrupt" " warning work not complete! "
}

trap "forcestop" SIGHUP SIGINT SIGTERM


# test if exist project <name> from packets list...
# $1 packet name
function check_project(){
local tmp=""
if [[ -n "${MAP[$1]}" ]]; then
	return 1
fi
return 0
}



#$1 build name
#$2 dir
function remove_path(){
local V=$(echo $MYPATH | sed -e 's/:/  /g')
local OLD=$2
MYPATH=""
for I in $V; do
	if [ "$I" != "$OLD" ]; then
		MYPATH="$MYPATH:$I" 
	fi
done
}


#$1 build name
#$2 dir
function add_path(){
local NEW=$2
local V=$(echo $MYPATH | sed -e 's/:/  /g')
for I in $V; do
	if [ "$I" == "$NEW" ]; then
		return 
	fi
done
MYPATH="$NEW:"$MYPATH
}

#$1 build name
#$2 dir
function set_path(){
MYPATH="$2"
}

#$1 project
#$2 build phase number 0,1,2.....
function insert_packet(){
local PRI=""
local SILENT=""
local INDEX=""
local NUM=0
local ID=0
local TPATH=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make"
				NUM=$?
				if [ $NUM -ne 0 ]; then
					ID=0
					while [  $ID -lt $NUM ]; do
						PRI=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$ID\"]/priority")		
						equs "$PRI"  
						if [ $? -eq 1 ]; then 
							error_c "Missing  build make id=$ID priority Phase $2" "project : $1"
						fi						
						#optional				
						INDEX="$PRI%$1%$STEP_NAME"
						BSEQ[$INDEX]="$INDEX"
						ID=$((ID+1))
					done	
				fi
			else
				warning_c "no build step $2  !" "project : $1"
			fi
		else
			warning_c "no build  !" "project : $1"
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi

}


#$1 project
#$2 build phase number 0,1,2.....
function manage_path_pre(){
local TPATH=""
local NUM=0
local MAX=0
local ID=0
#set -x ;trap read debug
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then	
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/pre"
				NUM=$?
				if [ $NUM -ne 0 ]; then 	
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/remove"
					NUM=$?
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/add"
					MAX=$?
					if [ $NUM -gt $MAX ]; then
						MAX=$NUM
					fi										
					ID=0
					while [ $ID -lt $MAX ]; do
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/remove[@id=\"$ID\"]")
						if [ "$TPATH" != "" ]; then
							remove_path $STEP_NAME $TPATH
						fi
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/add[@id=\"$ID\"]")
						if [ "$TPATH" != "" ]; then
							add_path $STEP_NAME $TPATH
						fi
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/pre/set")
						if [ "$TPATH" != "" ]; then
							set_path $STEP_NAME $TPATH
							break
						fi
						ID=$((ID+1))
					done 
				fi				
			fi	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}





#$1 project
#$2 build phase number 0,1,2.....
function manage_path_post(){
local TPATH=""
local NUM=0
local MAX=0
local ID=0
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then	
				xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/post"
				NUM=$?
				if [ $NUM -ne 0 ]; then 	
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/post/remove"
					NUM=$?
					xml_count $1 "/egg/project/build/step[@id=\"$2\"]/path/post/add"
					MAX=$?
					if [ $NUM -gt $MAX ]; then
						MAX=$NUM
					fi					
					ID=0
					while [ $ID -lt $MAX ]; do
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/post/remove[@id=\"$ID\"]")
						if [  "$TPATH"  !=  ""  ]; then
							remove_path $STEP_NAME $TPATH
						fi
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/post/add[@id=\"$ID\"]")
						if [  "$TPATH"  !=  ""  ]; then
							add_path $STEP_NAME $TPATH
						fi
						TPATH=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/path/post/set")
						if [ "$TPATH" != "" ]; then
							set_path $STEP_NAME $TPATH
							break
						fi
						ID=$((ID+1))
					done 
				fi					
			fi	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}


#$1 project
function getSourcePath(){
local RES=""
if [ -e $SOURCES/$1/configure ]; then
	RES=$SOURCES/$1	
else
	if [ -e $SOURCES/$1/$1-*/configure ]; then		
		RES=$(ls -d $SOURCES/$1/$1-* )		
	else
		if [ -e $SOURCES/$1/configure.ac ]; then
			RES=$SOURCES/$1	 
		else
			if [ -e $SOURCES/$1/$1-*/configure.ac ]; then				
				RES=$(ls -d $SOURCES/$1/$1-*)				
			else
				if [ -e $SOURCES/$1/Makefile ]; then
					RES=$SOURCES/$1	 
				else
					if [ -e $SOURCES/$1/$1-*/Makefile ]; then
						RES=$(ls -d $SOURCES/$1/$1-*)						
					else
						if [ -e $SOURCES/$1/Configure ]; then
						#perl
							RES=$SOURCES/$1 
						else
							if [ -e $SOURCES/$1/$1-*/Configure ]; then
							#perl
								RES=$(ls -d $SOURCES/$1/$1-*)									
							fi
						fi				
					fi
				fi
			fi
		fi
	fi
fi	
echo $RES
}



#$1 project
#$2 step id
#$3 fileout
#$4 build name
function generate_setenv(){
	local SRC=$(getSourcePath $1)	
	echo "#!/bin/sh" > "$3"
	echo "#unset all except $HOME ..." >> "$3"
	ENV=$(env | sed 's/=.*//' | tr '\n' ' ' | sed -e 's/HOME//g')
	echo "ENV=\"$ENV\"" >> "$3"		
	echo "for i in \$ENV ; do ">> "$3"
	echo " unset \$i" >> "$3"
	echo "done" >> "$3"
	echo "#done unset all" >> "$3"

	echo "#current project" >> "$3"	
	echo "export PROJECT=$1" >> "$3"
	echo "#current project name" >> "$3"
	echo "export PROJ_NAME=$1_$2" >> "$3"
	echo "#current sources for projects" >> "$3"	
	echo "export SOURCES=$SOURCES" >> "$3"
	echo "#current build path for projects" >> "$3"	
	echo "export BUILDS=$BUILD/$4">> "$3"
	echo "#current source for this project" >> "$3"	
	echo "export SOURCE=$SRC" >> "$3"
	echo "#current build path for this project" >> "$3"
	echo "export BUILD_PATH=$BUILD/$4/$1_$2" >> "$3"
	echo "#current build path usually 'build' for project" >> "$3"	
	echo "export BUILD=$BUILD/$4/$1_$2/build" >> "$3"
	echo "#file containt the status of build fro this projects : 0,1,2">> "$3"
	echo "export STATUS=$BUILD/$4/$1_$2/status" >> "$3"	
	echo "#current out of all builds for eggx environment">> "$3"
	echo "export IMAGES=$IMAGES" >> "$3"
	echo "#current out this project">> "$3"
	echo "export DEPLOY=$IMAGES/$4" >> "$3"	
	echo "#current Hardware ARCH this machine">> "$3"
	echo "export HW_ARCH=$HW_ARCH">> "$3"
	echo "#current ARCH this project">> "$3"
	echo "export ARCH=$ARCH">> "$3"
	echo "#current CROSS this project">> "$3"
	echo "export CROSS=$CROSS">> "$3"
	echo "#current CFLAGS this project">> "$3"
	echo "export CFLAGS=\"$CFLAGS\"" >> "$3"
	echo "#current CPPFLAGS this project">> "$3"
	echo "export CPPFLAGS=\"$CPPFLAGS\"" >> "$3"
	echo "#current CXXFLAGS this project">> "$3"
	echo "export CXXFLAGS=\"$CXXFLAGS\"" >> "$3"
	echo "#current LDFLAGS this project">> "$3"
	echo "export LDFLAGS=\"$LDFLAGS\"" >> "$3"
	echo "#current LIBS this project">> "$3"
	echo "export LIBS=\"$LIBS\"" >> "$3"
	echo "#current CPPFLAGS this project">> "$3"
	echo "export CPATH=\"$CPATH\"" >> "$3"
	echo "#current C_INCLUDE_PATH this project">> "$3"
	echo "export C_INCLUDE_PATH=\"$C_INCLUDE_PATH\"" >> "$3"
	echo "#current CPLUS_INCLUDE_PATH this project">> "$3"
	echo "export CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH\"" >> "$3"
	echo "#current CC this project">> "$3"
	echo "export CC=$CC" >> "$3"
	echo "#current CXX this project">> "$3"
	echo "export CXX=$CXX" >> "$3"
	echo "#current AS this project">> "$3"
	echo "export AS=$AS" >> "$3"
	echo "#current LD this project">> "$3"
	echo "export LD=$LD" >> "$3"
	echo "#current NM this project">> "$3"
	echo "export NM=$NM" >> "$3"
	echo "#current AR this project">> "$3"
	echo "export AR=$AR" >> "$3"
	echo "#current STRIP this project">> "$3"
	echo "export STRIP=$STRIP" >> "$3"
	echo "#current PATH this project">> "$3"
	echo "export PATH=$MYPATH" >> "$3"		
	echo "#current platform : from current path and gcc dumpmachine" >> "$3"	
	echo "export NATIVE=\$(gcc -dumpmachine)" >> "$3"
}

#$1 project
#$2 step
#$3 build path
#$4 value 0,1,2,
function setbuildstatus(){
local FILEIN="$3/status"
case $4 in
	0|1|2)
	echo $4 > $FILEIN
	;;
	*)
	error_c "Unknow state to build : $4" "project : $1"
	;;
esac
}

#$1 project
#$2 step
#$3 build path
# STATUS 0=INIT AFTER DOWNLOAD BEFORE do configure command
# STATUS 1=CONFIGURED After executed configure command
#STATUS  2=STABLE after build phase (make...install ...all stages) 
#on build is available  setbuildstatus 0,1,2 from xml file : ex on last  make/rule idxx/ 
#	<post  id="0">
#		<mode>code</mode>		
#		<value>setbuildstatus 2</value>
#	</post >
function getbuildstatus(){
local RES=0
local FILEIN="$3/status" 
local VV=""
VV=$(getFileSize "$FILEIN")
if [ $VV -eq 0 ]
then 
	#not exist , invalid ?..
	setbuildstatus "$3" 0
	VV="0"
else
	VV=$(cat "$FILEIN")
fi
return $VV
}

#$1 file to create rewrite
function prepare_script_head(){
local LINE=$(sed -n '/COPYTODEFAULTSCRIPT/{=;p}' $SCRIPT_DIR/functions.sh | sed -e 's/ /\n/g' | head -n 1)
LINE=$((LINE-1))
head $SCRIPT_DIR/functions.sh -n $LINE > "$1"
echo "">> "$1"
echo "">> "$1"
}


#$1 projects
#$2 Step
#$3 title to echo...
#$4 file to write 
#$5 BUILD NAME
#$6 status to check value else exit :if $6=1000 don't check
#$7 msg in stable mode
function prepare_script_generic(){
local VV=0
VV=$6
prepare_script_head "$4"
echo "function getbuildstatus(){">> "$4"
echo "local VV=\$(cat \$STATUS)">> "$4"
echo "return \$VV">> "$4"
echo "}">> "$4"
echo "">> "$4"
echo "">> "$4"
echo "function setbuildstatus(){">> "$4"
echo "case \$1 in ">>"$4"
echo "	0|1)">>"$4"
echo "	echo \$1 > \$STATUS">>"$4"
echo "	;;">>"$4"
echo "	2)">>"$4"
echo "	echo \$1 > \$STATUS">>"$4"
echo "	chmod 444 \$STATUS">>"$4"
echo "	;;">>"$4"
echo "	*)">>"$4"
echo "	error_c \"Unknow state to build : \$1\" \"project : $1\"" >>"$4"
echo "	;;">>"$4"
echo "esac">>"$4"
echo "}">> "$4"
echo "">> "$4"
echo "">> "$4"
echo "source $BUILD/$5/$1_$2/setenv.sh">> "$4"
if [ $VV -ne 1000 ]
then
	echo "getbuildstatus" >> "$4"
	echo "RES=\$?">> "$4"
	echo "if [ \$RES -eq 2 ]; then " >> "$4"
	echo "	print_ita \"Status\" \"stable\" \"skip $7 \"" >> "$4"
	echo "	exit 0" >> "$4"
	echo "fi" >> "$4"
	if [ $VV -eq 2000 ];  then
	       #configure skip if already configured(1) , ok at init (0) error on stable(2)
		VV=$((VV-2000))
		echo "if [ \$RES -eq 1 ]; then " >> "$4"
		echo "	exit 0" >> "$4"
		echo "fi" >> "$4"
	fi
	echo "if [ \$RES -ne $VV ]; then " >> "$4"
	echo "	error_c \"Build status error: current \$RES - request $6\" \"project : $1\"" >> "$4"
	echo "fi" >> "$4"
	echo "">> "$4"
	echo "">> "$4"
fi

echo "PWD=\$(pwd)">> "$4"
echo "cd \$BUILD" >> "$4"
echo "" >> "$4"
echo "" >> "$4"
}





#$1 projects
#$2 Step
#$3 title to echo...
#$4 file to write 
function end_script_generic(){
echo "" >> $4
echo "" >> $4
echo "cd \$PWD" >> "$4"
echo "" >> $4
echo "" >> $4
}



#$1 project
#$2 step id
#$3 file out
#$4 path build
#$5 build name
function add_pre_conf(){
declare -i i=0
local VALUE=""
local MODE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/value")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  pre conf id=$i value Phase $2" "project : $1"
				fi
				MODE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/pre[@id=\"$i\"]/mode")	
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  pre conf id=$i mode Phase $2" "project : $1"
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
				case $MODE in 
					SCRIPTS)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "$4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					SOURCE)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "source $4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					CODE)
						echo "$VALUE"  >> $3
						echo "if [ $? -ne 0 ]; then">> $3
						echo " error_c \"Custom command  Fail!\" \"$VALUE\"" >> $3
						echo "fi" >> $3
					;;		
					*)
					error_c "Unknow  pre build id=$i mode:$MODE Phase $2" "project : $1"
					;;
				esac				
				i=$((i+1))
				done 
			else
				echo "# no pre configure script available for prject : $1" >> $3
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
}


#$1 project
#$2 step id
#$3 file out
#$4 path build
#$5 build name
function add_post_conf(){
declare -i i=0
local VALUE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/post"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/value")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  post conf id=$i Phase $2" "project : $1"
				fi
				MODE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/post[@id=\"$i\"]/mode")	
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  post conf id=$i mode Phase $2" "project : $1"
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
				case $MODE in 
					SCRIPTS)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "$4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					SOURCE)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "source $4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					CODE)
						echo "$VALUE"  >> $3
						echo "if [ $? -ne 0 ]; then">> $3
						echo " error_c \"Custom command  Fail!\" \"$VALUE\"" >> $3
						echo "fi" >> $3
					;;		
					*)
					error_c "Unknow  post conf id=$i mode Phase $2" "project : $1"
					;;
				esac				
				i=$((i+1))
				done 
			else
				echo "# no post configure script available for prject : $1" >> $3
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
echo " "  >> $3
echo "setbuildstatus 1">>"$3"
echo " "  >> $3
echo " "  >> $3
}

#$1 project
#$2 step id
#$3 file out
#$4 silent
function add_extra_conf(){
declare -i i=0
local VALUE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/configure/extra"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				echo " \\" >> $3
				VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/configure/extra[@id=\"$i\"]")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  extra conf id=$i Phase $2" "project : $1"
				fi
				echo -n	"$VALUE "  >> $3
				i=$((i+1))
				done 
			fi
		fi	
		if  [ "$4" == "yes" ]; then 
			echo "  > $3.log 2>&1" >>  $3		
		fi
		echo " "  >> $3	
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
echo "RES=\$?" >> $3
echo "if [ \$RES -ne 0 ]; then" >> $3
echo "    error_c \"Configure return error: \$RES \" \"  - project : \$PROJECT step \$STEP\"" >> $3
echo "fi" >> $3 
}






#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread //max
#$7 make index 
#s8 build file
function add_rules_build(){
local NUM_R=0
local II=0
xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule"
	NUM_R=$?
	if [ $NUM_R -ne 0 ]; then
		II=0
		while  [  $II -lt $NUM_R  ];  do
			NAME=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$II\"]/name")	
			#NAME can be empty for do make ...
			#equs "$NAME"  
			#if [ $? -eq 1 ]; then 
			#	error_c "Missing  make rule name id=$i Phase $2" "project : $1"
			#fi
			THREAD=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$II\"]/thread")
			if [ "$THREAD" == "" ]; then 
				THREAD="$6"				
			else			
				if  [  $THREAD -gt $6 ] ; then 
					THREAD="$6"
				fi	
			fi						
			add_pre_build "$1" "$2" "$8" "$3" "$4" "$II" "$7"
			add_entry_in_main_build_script "$1" "$3"  "$8" "$5" "$THREAD" "$6" "$NAME"
			add_post_build "$1" "$2" "$8" "$3" "$4" "$II" "$7"
			II=$((II+1))
		done 
	fi
}


#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread //max 
#<make>
#<rule id=0>
#<name>all</name> 
#<pre id=0></pre>    optional
#<post id=0></post> optional
#<tread></thread>    optional
#</rule>
#</make>
#
function generate_build_rules(){
#build
local SH_BUILD=""
declare -i II=0
declare -i UU=0
local NAME
local TREAD
declare -i NUM_R=0
declare -i NUM_M=0
local PRI=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM_R=$?
		if [ $NUM_R -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make"
			NUM_M=$?
			if [ $NUM_M -ne 0 ]; then
				UU=0
				while [  $UU -lt $NUM_M  ]; do
					PRI=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$UU\"]/priority")
					local SH_BUILD="$3/build_$PRI.sh"
					rm -f "$SH_BUILD" 
					touch "$SH_BUILD"
					chmod +rwx "$SH_BUILD"
					prepare_script_generic "$1" "$2" "Start build " "$SH_BUILD" "$4" 1 "build"
					echo "declare -i start_time">> "$SH_BUILD"
					echo "declare -i stop_time">> "$SH_BUILD"
					echo "declare -i total_time">> "$SH_BUILD"
					add_rules_build "$1" "$2" "$3" "$4" "$5" "$6" "$UU" "$SH_BUILD"					
					end_script_generic "$1" "$2" "done  build " "$SH_BUILD"					
					UU=$((UU+1))					
				done	
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> "$SH_BUILD"
echo " "  >> "$SH_BUILD"
echo "setbuildstatus 2">> "$SH_BUILD"
echo " "  >> "$SH_BUILD"
echo " "  >> "$SH_BUILD"
#------------------------------------------------------------------------------------------------------------------
}

#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread

function generate_clean_rule(){
local SH_CLEAN="$3/clean.sh"
rm -f "$SH_CLEAN" 
touch "$SH_CLEAN" 
chmod +rwx "$SH_CLEAN" 
# clean 
prepare_script_generic "$1" "$2" "Start clean build " "$SH_CLEAN" "$4" 1 "clean"
echo "if [ -f \$BUILD/Makefile ]; then " >> "$SH_CLEAN"
if [ "$5" == "yes" ]; then 
	echo "	make -C \$BUILD clean > $SH_CLEAN 2>&1 " >> "$SH_CLEAN"
else
	echo "	make -C \$BUILD  clean ">> "$SH_CLEAN"
fi
echo "	if [ \$? -ne 0 ]; then">> "$SH_CLEAN"
echo "    	error_c \"Error on clean \" \"project $1\"" >>"$SH_CLEAN"
echo "	fi"  >> "$SH_CLEAN"
echo "fi" >> "$SH_CLEAN"
echo "" >> "$SH_CLEAN"
echo "" >> "$SH_CLEAN"
end_script_generic "$1" "$2" "done clean build " "$SH_CLEAN"
}







#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread
function generate_distclean_rule(){
local SH_DISTCLEAN="$3/distclean.sh"
rm -f "$SH_DISTCLEAN"  
touch "$SH_DISTCLEAN" 
chmod +rwx "$SH_DISTCLEAN" 
#distclean 
prepare_script_generic "$1" "$2" "Start distclean build " "$SH_DISTCLEAN" "$4" 1000
echo "cd \$PWD " >> "$SH_DISTCLEAN"
echo "chmod +w \$BUILD_PATH/status">> "$SH_DISTCLEAN"
echo "rm -f \$BUILD_PATH/status">> "$SH_DISTCLEAN"
echo "rm -rf \$BUILD/* " >> "$SH_DISTCLEAN"
echo "" >> "$SH_DISTCLEAN"
echo "" >> "$SH_DISTCLEAN"
echo "setbuildstatus 0">> "$SH_DISTCLEAN"
end_script_generic "$1" "$2" "done distclean build " "$SH_DISTCLEAN"
}



#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread
function generate_rebuild_rule(){
local NUM_R=0
local NUM_M=0
local UU=0
local PRI=0;
local SH_REBUILD="$3/rebuild.sh"
rm -f  "$SH_REBUILD" 
touch "$SH_REBUILD"
chmod +rwx "$SH_REBUILD"
#rebuild
prepare_script_generic "$1" "$2" "Start Rebuild " "$SH_REBUILD" "$4" 1000
echo "cd \$PWD">> "$SH_REBUILD"
echo "if [ \$? -ne 0 ]; then exit \$?; fi">> "$SH_REBUILD"
echo "$3/distclean.sh" >> "$SH_REBUILD"
echo "if [ \$? -ne 0 ]; then exit \$?; fi">> "$SH_REBUILD"
echo "$3/bootstrap.sh" >> "$SH_REBUILD"
echo "if [ \$? -ne 0 ]; then exit \$?; fi">> "$SH_REBUILD"
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM_R=$?
		if [ $NUM_R -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make"
			NUM_M=$?
			if [ $NUM_M -ne 0 ]; then
				UU=0
				while [  $UU -lt $NUM_M  ]; do
					PRI=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$UU\"]/priority")
					echo "$3/build_$PRI.sh">> "$SH_REBUILD"
					echo "if [ \$? -ne 0 ]; then exit \$?; fi">> "$SH_REBUILD"
					UU=$((UU+1))
				done
			fi
		fi
	fi
fi	
end_script_generic "$1" "$2" "done  rebuild " "$SH_REBUILD"
}
#$1 project
#$2 step id
#$3 path build
#$4 build name
#$5 silent
#$6 thread
function add_build_script(){
generate_setenv "$1" "$2" "$3/setenv.sh" "$4" "$5"
generate_clean_rule $@
generate_distclean_rule $@ 
generate_build_rules $@
generate_rebuild_rule $@
}

#$1 project
#$2 step id
#$3 file out
#$4 path build
#$5 build name
#$6 rule index
#$7 make index
function add_pre_build(){
declare -i i=0
local VALUE=""
local MODE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/value")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  pre build id=$i value Phase $2" "project : $1"
				fi
				MODE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/pre[@id=\"$i\"]/mode")	
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  pre build id=$i mode Phase $2" "project : $1"
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
				case $MODE in 
					SCRIPTS)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "$4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> "$3"
					;;		
					SOURCE)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "source $4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> "$3"
					;;		
					CODE)
						echo "$VALUE"  >> "$3"
						echo "if [ $? -ne 0 ]; then">> $3
						echo " error_c \"Custom command  Fail!\" \"$VALUE\"" >> $3
						echo "fi" >> $3						
					;;		
					*)
					error_c "Unknow  pre build id=$i mode:$MODE Phase $2" "project : $1"
					;;
				esac				
				i=$((i+1))
				done 
			else
				echo "# no pre build script available for prject : $1" >> "$3"
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
}



#$1 project
#$2 step id
#$3 file out
#$4 path build
#$5 build name
#$6 rule index
#$7 make index
function add_post_build(){
declare -i i=0
local VALUE=""
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
		NUM=$?
		if [ $NUM -ne 0 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				while  [ $i -lt $NUM ]; do
				VALUE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/value")	
				equs "$VALUE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  post build id=$i Phase $2" "project : $1"
				fi
				MODE=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/make[@id=\"$7\"]/rule[@id=\"$6\"]/post[@id=\"$i\"]/mode")	
				equs "$MODE"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  post build id=$i mode Phase $2" "project : $1"
				fi
				MODE=$(echo $MODE  | tr '[:lower:]' '[:upper:]')
				case $MODE in 
					SCRIPTS)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "$4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					SOURCE)
						rsync -sy "$REPO/$1/$VALUE" "$4/$VALUE"				
						echo "source $4/$VALUE  $1 $2 $5 $4 $REPO/$1 $SOURCES/$1 $IMAGES/$5"  >> $3
					;;		
					CODE)
						echo "$VALUE"  >> $3
						echo "if [ $? -ne 0 ]; then">> $3
						echo " error_c \"Custom command  Fail!\" \"$VALUE\"" >> $3
						echo "fi" >> $3
					;;		
					*)
					error_c "Unknow  post build id=$i mode:$MODE Phase $2" "project : $1"
					;;
				esac				
				i=$((i+1))
				done 
			else
				echo "# no post build script available for prject : $1" >> $3
			fi
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
echo " "  >> $3
}




#$1 project
#$2 build path
#$3 file out
#$4 silent 
#$5 threads
#$6 max thread
#$7 make rule name
function add_entry_in_main_build_script(){
echo "start_time=\$(date +%s)">> "$3"
echo " print_s_ita \"       Make \"  \"$7-$6:$5\"  \"start\"" >> "$3"
if [ "$4" == "yes" ]; then 
	echo "make -C \$BUILD -j$5 $7 > $3.log 2>&1 " >> "$3"
else
	echo "make -C \$BUILD  -j$5 $7 ">> "$3"
fi
echo "if [ \$? -ne 0 ]; then">> "$3"
echo "    error_c \"Error on build \" \"project : $1\"" >>"$3"
echo "fi"  >> "$3"
echo "stop_time=\$(date +%s)">> "$3" 
echo "total_time=\$((stop_time-start_time))">> "$3" 
echo "print_s_ita \"       ... \"  \"done\"  \"\$total_time sec\" ">> "$3" 
}


#$1 project
#$2 build phase number 0,1,2.....
function create_configure_cmd(){
local SILENT=""
local NUM=0
#set -x ; trap read debug
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then					
				SILENT=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/silent")
				#optional
				if [ $SILENT ]; then
					range_multi "$SILENT" "yes no"
					if [ $? -eq 0 ]; then 
						error_c "silent value error $SILENT-yes or no only! Phase $2" "project : $1"
					fi
				else
				#default
				SILENT="yes"
				fi
				THREADS=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/threads")
				#optional
				if [ $THREADS ]; then
					range_multi "$THREADS" "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16"
					if [ $? -eq 0 ]; then 
						error_c "Threads value error $THREADS-0..16 only! Phase $2" "project : $1"
					fi
				else
					#default
					THREADS=1
				fi							
			fi	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
local C_BUILD="$BUILD/$STEP_NAME/$1_$2"
local C_FILE="$C_BUILD/bootstrap.sh"
local DEST="$IMAGES/$STEP_NAME"
local SRC=$(getSourcePath $1)
rm  -rf "$C_BUILD"
mkdir -p "$C_BUILD"
if [ ! -e "$DEST" ] ; then mkdir -p "$DEST"; fi
touch "$C_FILE"
sync
chmod +x "$C_FILE" 
setbuildstatus "$1"  "$2" "$C_BUILD" 0
prepare_script_generic "$1"  "$2" "START CONFIGURE" "$C_FILE" "$STEP_NAME"  2000 "configure"
echo "declare -i start_time">> "$C_FILE"
echo "declare -i stop_time">> "$C_FILE"
echo "declare -i total_time">> "$C_FILE"
echo "start_time=\$(date +%s)">> "$C_FILE"
add_pre_conf "$1" "$2" "$C_FILE" "$C_BUILD"  "$STEP_NAME"
EXTSI=$(echo $SILENT  | tr '[:lower:]' '[:upper:]')
if [ "$EXTSI" != "YES" ]; then
	echo "set -x ">> $C_FILE
fi
if [ -e $SRC/configure ]; then
	mkdir -p "$C_BUILD/build"
	echo -n "$SRC/configure ">> $C_FILE
	add_extra_conf "$1" "$2" "$C_FILE"  "$SILENT" 
else
	if [ -e $SRC/configure.ac ]; then
		# add <pre> autoconf...
		mkdir -p "$C_BUILD/build"
		echo -n "$SRC/configure  ">> $C_FILE
		add_extra_conf "$1" "$2" "$C_FILE"  "$SILENT" 
	else
		if [ -e $SRC/Makefile ]; then
			ln -s  "$SRC" "$C_BUILD/build"
			echo  "#no configure is needed .... ">> $C_FILE
		else
			if [ -e $SRC/Configure ]; then
			#perl
				mkdir -p "$C_BUILD/build"
				echo -n "$SRC/Configure ">> $C_FILE
				add_extra_conf "$1" "$2" "$C_FILE"  "$SILENT" 
			else
				error_c "Configure script or Makefile missing" "project : $1"
			fi							
		fi		
	fi	
fi	
##
EXTSI=$(echo $SILENT  | tr '[:lower:]' '[:upper:]')
if [ "$EXTSI" != "YES" ]; then
	echo "set +x ">> $C_FILE
fi
add_post_conf "$1" "$2" "$C_FILE" "$C_BUILD"  "$STEP_NAME"
echo "stop_time=\$(date +%s)">> "$C_FILE" 
echo "total_time=\$((stop_time-start_time))">> "$C_FILE" 
echo "print_s_ita \"       ... \"  \"done\"  \"\$total_time sec\" ">> "$C_FILE" 
end_script_generic  "$1"  "$2" "END CONFIGURE" "$C_FILE"
#build
add_build_script "$1" "$2"  "$C_BUILD"  "$STEP_NAME" "$SILENT" "$THREADS" 
print_ita "STEP : $2:$3" "$1"  "configured done !"
}

#$1 project
#$2 build phase number 0,1,2.....
#$3 make priority
#$4 build name
function create_main_scripts(){
local FILES="bootstrap clean distclean build_$3 rebuild setenv"
local RES=0
local VV=""
local FMAIN="$BUILD/$4/step_$2.sh"
RES=$(getFileSize "$FMAIN")
if [ $RES -eq 0 ]; then 
	touch "$FMAIN"
fi
for VV in $FILES; do
	echo "# execute $VV.sh for project $1 in folder $BUILD/$4/$1_$3">>"$FMAIN"
	echo "function $VV""___$1 (){">>"$FMAIN"
	echo "   $BUILD/$4/$1_$3/$VV.sh ">>"$FMAIN"
	echo "}">>"$FMAIN"
	echo "">>"$FMAIN"
	echo "">>"$FMAIN"
done
}

#$1 project
#$2 build phase number 0,1,2.....
#$3 make priority
#$4 build name
function create_main_entry(){
local FMAIN="$BUILD/$4/step_$2.sh"
RES=$(getFileSize "$FMAIN")
if [ $RES -ne 0 ]; then 
echo "#END_FUNCTION_STEP">>"$FMAIN"
echo "">>"$FMAIN"
echo "">>"$FMAIN"
echo "#search from argv function to call">>"$FMAIN"
echo "#bootstrap bash 1 call bootstrap_bash_1">>"$FMAIN"
echo "function main (){">>"$FMAIN"
echo "local BUILDS=\"\"">>"$FMAIN"
echo "local VV=\"\"">>"$FMAIN"
echo "local LINE=\"\"">>"$FMAIN"
echo "local PRJ=\"\"">>"$FMAIN"
echo "local SCRIPT=\"\"">>"$FMAIN"
echo "if [ \"\$1\" == \"listall\" ]; then">>"$FMAIN"
echo "   RES=0 ">>"$FMAIN"
echo "	 while IFS='' read -r LINE || [[ -n \"\$LINE\" ]]; do">>"$FMAIN"
echo "   if [ \$RES -eq 0 ]; then">>"$FMAIN"
echo "       VV=\$(echo \$LINE | grep START_FUNCTION_STEP)">>"$FMAIN"
echo "       if [ \"\$VV\" == \"\" ]; then">>"$FMAIN"
echo "          continue ">>"$FMAIN"
echo "       fi ">>"$FMAIN"
echo "       RES=1 ">>"$FMAIN"
echo "   fi ">>"$FMAIN"
echo "   VV=\$(echo \$LINE | grep END_FUNCTION_STEP)">>"$FMAIN"
echo "   if [ \"\$VV\" != \"\" ]; then">>"$FMAIN"
echo "      break ">>"$FMAIN"
echo "   fi ">>"$FMAIN"
echo "   VV=\$(echo \$LINE | grep function)">>"$FMAIN"
echo "   if [ \"\$VV\" != \"\" ]; then < \$0">>"$FMAIN"
echo "   	VV=\$(echo \$VV | sed -e 's/function//g' | sed -e 's/(//g'| sed -e 's/)//g'| sed -e 's/{//g' | sed -e 's/___/  /g')">>"$FMAIN"
echo "   	SCRIPT=\$(echo \$VV | awk '{print \$1}')">>"$FMAIN"
echo "   	PRJ=\$(echo \$VV | awk '{print \$2}')">>"$FMAIN"
echo "		print_c \"\$YELLOW\" \"function : \" \"\$GREEN_LIGHT\" \"\$SCRIPT\" \"\$WHITE\" \"\$PRJ\" ">>"$FMAIN"
echo "   fi ">>"$FMAIN"
echo "   done < \$0">>"$FMAIN"
echo "   exit 0">>"$FMAIN"
echo "fi">>"$FMAIN"
echo "if [ \$# -ne 2 ]; then">>"$FMAIN"
echo "    echo usage : ./step_xx.sh scripts project phase">>"$FMAIN"
echo "    exit 1">>"$FMAIN"
echo "fi">>"$FMAIN"
echo "if [ \"\$1\" == \"build\" ]; then">>"$FMAIN"
echo "    BUILDS=\$(ls $BUILD/$4/$1_$2/build_*.sh)">>"$FMAIN"
echo "    for VV in \$BUILDS; do">>"$FMAIN"
echo "    \$VV">>"$FMAIN"
echo "    if [ \$? -ne 0 ]; then ">>"$FMAIN"
echo "    	exit 1">>"$FMAIN"
echo "    fi">>"$FMAIN"
echo "    done">>"$FMAIN"
echo "else">>"$FMAIN"
echo "	 if [ \"\$1\" == \"setenv\" ]; then">>"$FMAIN"
echo "	    cat $BUILD/$4/$1_$2/\$1.sh">>"$FMAIN"
echo "	 else">>"$FMAIN"
echo "      $BUILD/$4/$1_$2/\$1.sh">>"$FMAIN"
echo "	 fi">>"$FMAIN"
echo "fi">>"$FMAIN"
echo "}">>"$FMAIN"
echo "">>"$FMAIN"
echo "">>"$FMAIN"
echo "# main \$@ : req prj step">>"$FMAIN"
echo "main \$@">>"$FMAIN"
fi

chmod +x "$FMAIN"
}

#$1 project
#$2 build phase number 0,1,2.....
#$3 make priority
#$4 build name
function configure_packet(){
manage_path_pre  $1  $2
create_configure_cmd "$1" "$2" "$3"
manage_path_post $1  $2
create_main_scripts $@
sync
}


#$1 build phase number 0,1,2.....
function read_default_for_step(){
local VV=""
local VALUE=""
local VAR=""
local NAMES="step_name info cc cxx as ld nm ar strip cflags cppflags cxxflags \
			ldflags libs cpath c_include_path cplus_include_path \
			arch cross"
if [ -f $REPO/conf.egg ]; then
	#set -x ; trap read debug
	NUM=$(xmlstarlet sel -t  -v "count(/egg/defaults/step[@id=\"$1\"])" -n $REPO/conf.egg)	
	if [ $NUM -eq 1 ]; then
		for VV in $NAMES; do
			VAR=$(echo $VV |   tr '[:lower:]' '[:upper:]')
			VALUE=$(xmlstarlet sel -t  -v "egg/defaults/step[@id=\"$1\"]/$VV" -n $REPO/conf.egg)
			if [ "$VALUE" ]; then 	
				if [ "$VAR" == "INFO" ]
				then
					info_c "$VALUE"
				else				
					print_ita "Set   ($1) " "$VAR" "$VALUE"
					eval $VAR='$VALUE'
					export "$VAR"
				fi	
			else
				print_ita "Unset ($1) " "$VAR" "..."
				unset "$VAR"	
			fi
		done
	else
		if [ $NUM -eq 0 ]; then
			warning_c "missing defaults conf for step $1"
		else
			error_c "errata conf in main conf.egg" "Step id=$1 duplicate" 
		fi
	fi
else
	error_c "Missing conf.egg file " "on repo"
fi
}

#$1 number id
#$@ argv optional
function configure_all_packet(){
#set -x; trap read debug
local V=""
isNumber $1
if [ $? -ne 0 ]; then
	error_c "first input param must be the step number!" "configure_all <step x> <optional projets>"
fi

local ID=$1
local PRJS=""
local PRI=""
local NAME=""
shift

if [ "$#" -eq  0 ]; then
	PRJS=$ALL_PACKETS
else
	PRJS=$@
fi

#unset BSEQ
#declare -A BSEQ
#read_default_for_step "$ID"
#for V in $PRJS; do
#	insert_packet "$V" "$ID"
#done
#SORTREQ=$(echo ${BSEQ[*]}| tr " " "\n" | sort -n )

prepare_seq_priority "$ID"

MYPATH=$START_PATH
V=${SORTREQ[0]}
if [ "$V" ]; then
	PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
	PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')	
	if [ ! -e "$BUILD/$STEP_NAME" ]; then
		mkdir -p "$BUILD/$STEP_NAME"
	fi
	prepare_script_head "$BUILD/$STEP_NAME/step_$ID.sh"	
	echo "#START_FUNCTION_STEP">>"$BUILD/$STEP_NAME/step_$ID.sh"
	for V in $SORTREQ; do
		PRJS=$(echo -n $V | sed 's/%/ /g' | awk '{print $2}')
		PRI=$(echo -n $V | sed 's/%/ /g' | awk '{print $1}')		
		if [ "$PRJS" ] ; then 
			configure_packet  "$PRJS" "$ID" "$PRI" "$STEP_NAME"
		fi
	done
	create_main_entry "$PRJS" "$ID" "$PRI" "$STEP_NAME"
fi	
}







#$1 build phase number 0,1,2.....
function read_default_for_step(){
local VV=""
local VALUE=""
local VAR=""
local NAMES="step_name info cc cxx as ld nm ar strip cflags cppflags cxxflags \
			ldflags libs cpath c_include_path cplus_include_path \
			arch cross"
if [ -f $REPO/conf.egg ]; then
	#set -x ; trap read debug
	NUM=$(xmlstarlet sel -t  -v "count(/egg/defaults/step[@id=\"$1\"])" -n $REPO/conf.egg)	
	if [ $NUM -eq 1 ]; then
		for VV in $NAMES; do
			VAR=$(echo $VV |   tr '[:lower:]' '[:upper:]')
			VALUE=$(xmlstarlet sel -t  -v "egg/defaults/step[@id=\"$1\"]/$VV" -n $REPO/conf.egg)
			if [ "$VALUE" ]; then 	
				if [ "$VAR" == "INFO" ]
				then
					info_c "$VALUE"
				else				
					print_ita "Set   ($1) " "$VAR" "$VALUE"
					eval $VAR='$VALUE'
					export "$VAR"
				fi	
			else
				print_ita "Unset ($1) " "$VAR" "..."
				unset "$VAR"	
			fi
		done
	else
		if [ $NUM -eq 0 ]; then
			warning_c "missing defaults conf for step $1"
		else
			error_c "errata conf in main conf.egg" "Step id=$1 duplicate" 
		fi
	fi
else
	error_c "Missing conf.egg file " "on repo"
fi
}

#$1 ID BUILD STEP
function prepare_seq_priority(){
local V=""
unset BSEQ
declare -A BSEQ
read_default_for_step "$1"
for V in $ALL_PACKETS; do
	insert_packet $V $1
done	
SORTREQ=$(echo ${BSEQ[*]}| tr " " "\n" | sort -n )
}

#set numero massimo di step a disposizone
function get_max_step(){
MAX_STEP=$(xmlstarlet sel -t  -v "count(/egg/defaults/step)" -n $REPO/conf.egg)
}




#print build start 
#$1 pririty
#$2 name
#$3 project
function print_build_msg(){
print_ita  "BUILD : $1"  "$2"  "$3"
}

#print build start 
#$1 pririty
#$2 name
#$3 project
function print_conf_msg(){
print_ita  "CONF  : $1"  "$2"  "$3"
} 

#print build start 
#$1 pririty
#$2 name
#$3 project
function print_clean_msg(){
print_ita  "CLEAN : $1"  "$2"  "$3"
}


#none
function build_all(){
local HAVE_BUILD=0
local STATUS=0
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_conf_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/bootstrap.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			STATUS=$(cat $BUILD/$PRJ/$NAME/status)
			if [ $STATUS -ne 2 ]; then
				HAVE_BUILD=1
			fi
			print_build_msg "$PRI" "$NAME" "$PRJ"
			"$BUILD/$PRJ/$NAME/build_$PRI.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			
			sync
		fi	
	done
	ID=$((ID+1))
done
if [ $HAVE_BUILD -ne 0 ]; then 
	packetize_all
fi	
}


#none
function packetize_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
local STATUS=0
local RESULT=0
if [ $NOPKT -eq 1 ];then 
	return 0
fi
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [[ $(getFileSize "$BUILD/$PRJ/$NAME/status") != "0" ]]; then
			STATUS=$(cat "$BUILD/$PRJ/$NAME/status")
			if [ $STATUS -ne 2 ]; then
				RESULT=1
				break
			fi
		fi
	done
	ID=$((ID+1))
done
if [ $RESULT -eq 0 ]; then 	
	local PWD=$(pwd)
	start_time=$(date +%s)
	print_ita "PKT" "$PRJ" "..." 
	V=$(getFileSize $IMAGES/$PRJ.tar.bz2)
	if [  $V -ne 0  ]; then  
		rm -f $IMAGES/$PRJ.tar.bz2 
		rm -f $IMAGES/$PRJ.tar.bz2.md5
	fi
	cd "$IMAGES/$PRJ"
	tar -cjSf $IMAGES/$PRJ.tar.bz2   .
	md5sum $IMAGES/$PRJ.tar.bz2 > $IMAGES/$PRJ.tar.bz2.md5
	cd $PWD
	ID=0;
	while [ $ID -lt $MAX_STEP ] ; do
		prepare_seq_priority $ID
		for V in $SORTREQ; do
			V=$(echo $V  | sed -e 's/%/   /g')
			PRI=$(echo $V | awk '{print $1}')
			NAME=$(echo $V | awk '{print $2}')"_$ID"
			PRJ=$(echo $V | awk '{print $3}')
			rm -rf $BUILD/$PRJ/$NAME/build
			rm -rf $BUILD/$PRJ/$NAME/*.log
			mkdir -p $BUILD/$PRJ/$NAME/build
		done
		ID=$((ID+1))
	done
	stop_time=$(date +%s)
	total_time=$((stop_time-start_time))
	print_ita "$PRJ.tar.bz2"  "$(getFileSize $IMAGES/$PRJ.tar.bz2 ) Bytes"  "$total_time sec"
else
	error_c "$PRJ contain packeges not in ready to packetize " "project : $NAME" 
fi
print_del_ita
}

#none
function compile_all(){
local HAVE_BUILD=0
local STATUS=0
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
#set -x ; trap read debug
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_build_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			STATUS=$(cat $BUILD/$PRJ/$NAME/status)
			if [ $STATUS -ne 2 ]; then
				HAVE_BUILD=1
			fi
			"$BUILD/$PRJ/$NAME/build_$PRI.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
		fi
	done
	ID=$((ID+1))
done
if [ $HAVE_BUILD -ne 0 ]; then 
	packetize_all
fi	
}

#none
function clean_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_clean_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/clean.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
		fi
	done
	ID=$((ID+1))
done
}

#none
function distclean_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_clean_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/distclean.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
		fi
	done
	ID=$((ID+1))
done
}

#$1 function to execute
#$2 ID step build
#$3 ... SN projects
#$@ from argv build.sh
function exec_single(){
#trovo nomi build per ogni progetto
local ID=0
local PRJ_NAMES=""
local PRI=""
local NAME=""
local PRJ=""
local SEQ=""
local FUNCTION=""
if [ ! "$1" ]; then
	error_c "Input missing function to execute  !!"
fi
FUNCTION="$1  "
isNumber $2
if [ $? -ne 0 ]; then
   error_c "$2 : Input step isn't a number !!"
fi
ID=$2
if [ ! "$3" ]; then
	error_c "Input missing project  !!"
fi
shift
shift
# set -x ; trap read debug

PRJ_NAMES=$@

local PWD=$(pwd)
prepare_seq_priority $ID
for V in $PRJ_NAMES; do
	for I in $@; do
		for T in $SORTREQ; do
			SEQ=$(echo $T | grep $V | grep $I )
				if [ "$SEQ" != "" ]; then 
					break;
				fi
		done
		SEQ=$(echo $SEQ  | sed -e 's/%/   /g')
		PRI=$(echo $SEQ | awk '{print $1}')
		NAME=$(echo $SEQ | awk '{print $2}')"_$ID"
		PRJ=$(echo $SEQ | awk '{print $3}')
		if [ -d "$BUILD/$V/$NAME" ]; then
			$FUNCTION   "$PRI" "$NAME" "$PRJ" "$BUILD/$V/$NAME"
		fi
	done 
done
}

function exec_build(){
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_build_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/clean.sh"
"$PATH/bootstrap.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
"$PATH/build_$PRI.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
}

#$@ from argv build.sh
function build_single(){
local ARGV="$@"
exec_single "exec_build" $ARGV
}

function exec_compile(){
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_build_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/build_$PRI.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
}

#$@ from argv build.sh
function compile_single(){
local ARGV="$@"
exec_single "exec_compile" $ARGV
}


function exec_clean(){
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_clean_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/clean.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
}

#$@ from argv build.sh
function clean_single(){
local ARGV="$@"
exec_single "exec_clean" $ARGV
}

function exec_distclean(){
local PRI=$1
local NAME=$2
local PRJ=$3
local PATH=$4
print_clean_msg "$PRI" "$NAME" "$PRJ"
cd "$PATH"
"$PATH/distclean.sh"
if [ $? -ne 0 ] ; then
	exit -1;
fi
}

#$@ from argv build.sh
function distclean_single(){
local ARGV="$@"
exec_single "exec_distclean" $ARGV
}


#$@
function build_all_packet(){
if [ "$1" == "" ]; then
	build_all
else
	build_single $@
fi
print_del_ita
}

#$@
function compile_all_packet(){
if [ "$1" == "" ]; then
	compile_all
else
	compile_single $@
fi
print_del_ita
}

#$@
function clean_all_packet(){
if [ "$1" == "" ]; then
	clean_all
else
	clean_single $@
fi
print_del_ita
}

#$@
function distclean_all_packet(){
if [ "$1" == "" ]; then
	distclean_all
else
	distclean_single $@
fi
print_del_ita
}



#$ARGV TODO
function config_all_step(){
declare -i CONF_NUM=0
if [ $# -eq 0 ]; then
	while [ $CONF_NUM -lt $MAX_STEP ]; do 
		configure_all_packet  $CONF_NUM $@
		if [ $? -ne 0 ]; then 
			exit 1
		fi
		CONF_NUM=$((CONF_NUM+1))
	done
else
	isNumber $1
	if [ $? -eq 0 ]; then	
		CONF_NUM=$1
		shift
		configure_all_packet $CONF_NUM $@
		if [ $? -ne 0 ]; then 
			exit 1
		fi
	else
		error_c " Missing step number " "usage ./egg configure 0<-- step "
	fi
fi
print_del_ita
}



#$ARGV 
# ex 0 gcc -> try step of project gcc
function shell_packet(){
local PRJ=""
local V=""
local i=""
local NUM=$1
isNumber $1
if [ $? -ne 0 ]; then
   error_c "$1 : Input step isn't a number !!"
fi
if [ ! "$2" ]; then
	if [ $NUM -lt $MAX_STEP ]; then
		prepare_seq_priority $NUM
		if [ "$SORTREQ" == "" ]; then
			error_c "Step $1 for project $2 not configured!" "project : $2"
		fi
		PRJ=${SORTREQ[0]}
		V=$(echo $PRJ  | sed -e 's/%/   /g')
		NAME=$( echo $V | awk '{print $3}' )
		if [ "$NAME" == "" ]; then			
				error_c "Step $1 unknown name!" "project : $2"
		fi
		print_c "$GREEN_LIGHT" "execute cd : $BUILD/$NAME"
		print_c "$GREEN_LIGHT" "do exit to return..."
		cp $HOME/.bashrc /tmp/egg_shellrc
		echo "cd $BUILD/$NAME" >> /tmp/egg_shellrc
		bash --noprofile --rcfile /tmp/egg_shellrc
	else
		error_c "Input step too BIG !!"
	fi	
else
	if [ $NUM -lt $MAX_STEP ]; then
		prepare_seq_priority $NUM
		if [ "$SORTREQ" == "" ]; then
			error_c "Step $1 for project $2 not configured!" "project : $2"
		fi
		for PRJ in $SORTREQ; do
			V=$(echo $PRJ  | sed -e 's/%/   /g')
			NAME=$( echo $V | awk '{print $2}' )
			if [ "$NAME" == "$2" ]; then			
				PRJ=$( echo $V | awk '{print $3}' )
				break;
			fi
		done
		if [ $PRJ ]; then
		#V=$(pwd)
		print_c "$GREEN_LIGHT" "execute cd : $BUILD/$PRJ/$2_$1"
		print_c "$GREEN_LIGHT" "do exit to return..."
		print_c "$GREEN_LIGHT" "do source ./setenv.sh to enter in build environment"
		cp $HOME/.bashrc /tmp/egg_shellrc
		echo "cd $BUILD/$PRJ/$2_$1" >> /tmp/egg_shellrc
		bash --noprofile --rcfile /tmp/egg_shellrc 
		#cd $V	
		set +x
		fi
	else
		error_c "Input step too BIG !!"
	fi
fi
}

#recussive edit on repo project
function edit_repo_files(){
local ALL_FILES=$(ls "$OREPO")
local VV=""
#cp "$OREPO/conf.egg" "$OREPO/conf.egg_$(date +%d-%m-%y_%H:%M:%S).backup"
$EDITOR "$OREPO/conf.egg"
for VV in $ALL_FILES;  do
if [ "$VV" == "." ]; then continue; fi
if [ "$VV" == ".." ]; then continue; fi
if [ -d "$OREPO/$VV" ]; then 
	cp "$OREPO/$VV/conf.egg" "$OREPO/$VV/conf.egg_$(date +%d-%m-%y_%H:%M:%S).backup"
	$EDITOR "$OREPO/$VV/conf.egg" 
fi
done
}


#$ARGV 
#  gcc -> edit conf.egg of project gcc
function edit_packet(){
local PRJ=""
local V=""
if [ ! "$1" ]; then
	error_c "Missing Input project "
fi
check_project "$1"
if [ $? -ne 0 ]; then
	$EDITOR "$OREPO/$1/conf.egg" > /dev/null  &
else
		if [ "$1" == "self" ]; then
				$EDITOR "egg" > /dev/null  &
		else
			case $1 in
				self.conf)
				$EDITOR "$OREPO/conf.egg" > /dev/null  &
				;;
				self.source)
				$EDITOR "$SCRIPT_DIR/sources.sh" > /dev/null  &
				;;
				self.functions)
				$EDITOR "$SCRIPT_DIR/functions.sh"  > /dev/null  &
				;;
				self.repo)
				edit_repo_files
				;;
				*)
				error_c "Missing project in $OREPO " "project : $1"
				;;
			esac	
		fi
fi
}

function show_info(){
print_ita "author" "Angelo" "Coppi"
print_ita "email" "angelogkcop@" "hotmail.com"
print_ita "git" "https://github.com" "ataima"
exit 0
}


#$ARGV
function redoall(){
$SCRIPT_DIR/sources.sh
	if [ $? -ne 0 ]; then 
		exit 1
	fi
	config_all_step
	build_all_packet
}

# $1 optional 
function list_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		print_ita "STEP : $ID" "PRI : $PRI" "$NAME"
	done
	ID=$((ID+1))
done
}




#$1 step nn 
#$2 optional prj
function freeze_step(){
local ID=$1 
local V=""
local PRI=""
local NAME=""
local PRJ=""
local RNAME="$2_$1"
prepare_seq_priority $ID
#set -x ; trap read debug
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		V=$( getFileSize $BUILD/$PRJ/$NAME/status)
		if [ $V -ne 0 ]; then 
			if [ $# -eq 1 ]; then
				
					chmod +w "$BUILD/$PRJ/$NAME/status"
					echo 2 > "$BUILD/$PRJ/$NAME/status"
					chmod -w "$BUILD/$PRJ/$NAME/status"
					print_ita "STEP : $ID" "PRI : $PRI" "$NAME -> stable"
			fi
			if [ $# -eq 2 ] && [  "$NAME" == "SRNAME" ]; then
					chmod +w "$BUILD/$PRJ/$NAME/status"
					echo 2 > "$BUILD/$PRJ/$NAME/status"
					chmod -w "$BUILD/$PRJ/$NAME/status"
					print_ita "STEP : $ID" "PRI : $PRI" "$NAME -> stable"
			fi
		fi				
	done
}

#$1 optional step
#$2 optional projects
function freeze_build(){
local FNUM=0
if [ $# -eq 0 ];  then 
while [ $FNUM -lt $MAX_STEP ] ; do
	freeze_step $FNUM
	FNUM=$((FNUM+1))
done
	
else
	freeze_step $1 $2
fi
}



#$1 new repo to set repo
function set_repo(){
local RES=""
RES=$(ls -d $1)
if [ "$RES" ]; then 
	rm -f $OROOT/repo
	ln -s $1 $OROOT/repo
	sync
	main listall
else
	error_c "setrepo : direcory $1 " "not exist!"
fi	
}


#$1 file with list of repos
function multi_repo(){
local PWDM=""
local RES=""
local NUMM=0
local IDM=0
local FILE=""
local PATHS=""
#set -x; trap read debug
if [ $# -ne 1 ]; then
	error_c "multi command  accept only one arg" "input file xml with repos list"
fi 
RES=$(getFileSize $1)
if [ $RES -eq 0 ]; then 
	error_c "multi command  " "input file is empty"
fi
xml_multi_repo_count "$1" "/multi/repo" 
NUMM=$?
while [  $IDM -lt $NUMM ]; do
	FILE=$(xml_multi_repo_value "$1" "/multi/repo[@id=\"$IDM\"]")
	if [ "$FILE" != "" ]; then
		RES=$(ls -d "$FILE")
		if [ "$RES" != "" ]; then 
			RES=$(getFileSize $FILE/conf.egg)
			if [ $RES -ne 0 ]; then
			# ok conf.egg exist
				PATHS=$(ls -d $FILE/*)
				local VV
				for VV in $PATHS; do
					if [ -d $VV ]; then 
						RES=$(getFileSize $VV/conf.egg)
						if [ $RES -eq 0 ]; then
							error_c "multi command  " "File : $VV/conf.egg empty or not exist"
						fi
					fi
				done
			else
				error_c "multi command  " "File : $FILE/conf.egg empty or not exist"
			fi
		else
			error_c "multi command  " "File : $1 repo id=$IDM not is a directory"
		fi
	else
		error_c "multi command  " "File : $1 repo id=$IDM value missing"
	fi
	#ok repo valid
	print_ita "REPO : ID=$IDM" "$FILE" "OK"
	IDM=$((IDM+1))	
done	
warning_c "Multi repo build can start" "For complete build is required many time " "and at the end, only the packets of repo are available" "but all build tree are empty"
print_c "$YELLOW"  "Continue ? [s,n]"
read -r
RES=$(echo $REPLY  | tr '[:lower:]' '[:upper:]')
if [ "$RES" == "S" ]; then 
	IDM=0
	PWDM=$(pwd)
	while [  $IDM -lt $NUMM ]; do
		cd "$PWDM"
		rm -rf $SOURCES
		sync
		rm -rf $REPO
		sync
		rm -rf $BUILD
		sync
		FILE=$(xml_multi_repo_value "$1" "/multi/repo[@id=\"$IDM\"]")
		rm -f $OROOT/repo
		sync
		ln -s $FILE $OROOT/repo
		sync
		main redoall		
		if [ $? -ne 0 ] ; then 
		exit 1
		fi		
		IDM=$((IDM+1))	
	done
	cd "$PWDM"
	rm -rf $SOURCES
	sync
	rm -rf $REPO
	sync
	rm -rf $BUILD
	sync
	return 0
else
	return 1
fi
}



function usage(){
	print_c "$BLUE_LIGHT" "usage : ./build.sh <option> command  <args to pass subcommand>"
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "option -D or --debug : set debug mode" 
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "option -Q or --nopacketize : dont craete output tar" 
	print_c  "$YELLOW" "COMMAND" "$GREEN" "source : download all sources from repo projects"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "configure : configure all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "do : configure+build    all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "build :   build all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "redoall : clear all build and deploy  and redo source + configure+do"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "shell <step xx> <project nn>: open a shell with setenv for step xx of project nn"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "clean <option step xx> <option project nn>: clean all, clean all step, clean all step:project"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "distclean <option step xx> <option project nn>: remove build dir for all, all step,  step:project"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "edit <project nn>: edit a conf.egg file of project nn"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "reset : remove working path: $ROOT/build, $ROOT/image, $ROOT/repo, $ROOT/source "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "info : show program info..."
	print_c  "$YELLOW" "COMMAND" "$GREEN" "packetize : create a tar of the output "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "multi <file.egg list of repos >: sequence building of project in list "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "listall : list current repo "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "setrepo <path with new repo> : set a new repo and listall "
	print_c  "$YELLOW" "COMMAND" "$GREEN" "freeze nn < step number> : set status stable for specifi step number : <optional project> "
	exit 1
}

function reset_all(){
	local VV=""
	warning_c "WARNING : this operation is unrecoverable" "Do You want continue? <y,n>"
	read -r ;
	VV=$(echo $REPLY  | tr '[:lower:]' '[:upper:]')
	if [ "$VV" == "Y" ]
	then
		local LL="$ROOT/build  $ROOT/source  $ROOT/images $ROOT/repo"
		local TT=""
		for TT in $LL
			do			
				if  [  -d $TT ]
				then					
					local SIZE=$(du -sh $TT | awk '{print $1}')
					print_ita " REMOVE : "  "$TT" "$SIZE"
					rm -rf "$TT"
				else
					print_ita " WARNING : "  "$TT" "not exist"		
				fi	
			done
		if [ -d "$ROOT/store" ]	
		then
			print_ita " .... "  "$ROOT/store" "$(du -sh $ROOT/store| awk '{print $1}')"		
		else
			print_ita " WARNING : "  "$ROOT/store" "not exist"	
			rm -rf $ROOT	
		fi	
	fi
}


function default_do(){
        build_all_packet
}


#$1 build id number
function main(){
local torun=default_do
NOPKT=0
if [ $# -ne 0 ]; then
for i in $@; do
case $i in 
	-D|--debug)
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	set -x
	shift
	;;	
	-Q|--nopacketize)
	NOPKT=1
	warning_c "quick mode , no packetize output..."
	shift
	;;	
	source)
	torun=$SCRIPT_DIR/sources.sh
	shift
	break
	;;
	shell)
	torun=shell_packet
	shift
	break
	;;	
	configure)
	torun=config_all_step
	shift
	break
	;;	
	edit)
	torun=edit_packet
	shift
	break
	;;	
	build)
	torun=compile_all_packet
	shift
	break
	;;
	reset)
	torun=reset_all
	shift
	break
	;;	
	clean)
	torun=clean_all_packet
	shift
	break
	;;
	multi)
	torun=multi_repo
	shift
	break
	;;		
	distclean)
	torun=distclean_all_packet
	shift
	break
	;;	
	do)
	torun=build_all_packet
	shift
	break
	;;		
	redoall)
	torun=redoall		
	shift
	break
	;;	
	info)
	torun=show_info		
	break
	;;	
	packetize)
	torun=packetize_all		
	break
	;;	
	listall)
	torun=list_all		
	break
	;;	
	setrepo)
	torun=set_repo		
	shift
	break
	;;
	freeze)
	torun=freeze_build		
	shift
	break
	;;
	*)
	usage
	error_c "Command line" " unknow option $i"
	;;
esac
done

fi




#set log to download
if [ ! -d $ROOT ]; then 
	mkdir -p $ROOT
fi

# sync repo file to build path 
rsync -ry $OREPO $REPO

xml_get_env 




#sort project in repo to bin search
ALL_PACKETS=$(ls $OROOT/repo  | sed 's/conf.egg//g')

unset MAP
declare -A MAP    

for key in $ALL_PACKETS; do MAP[$key]="$key"; done  

if [ $? -ne 0 ]; then
	error_c "Cannot  sync work repository"
fi


get_max_step
"$torun" "$@"
}

function legal(){
print_c "$WHITE" "Copyright (C) 2017 Angelo Coppi. <angelogkcop@hotmail.com>"
print_c "$GREEN" "This is free software; see the LICENSE file for copying conditions."
print_c "$GREEN" "There is NO warranty; not even for MERCHANTABILITY or FITNESS "
print_c "$GREEN" "FOR A PARTICULAR PURPOSE."
}


legal
main "$@"
