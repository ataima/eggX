#!/bin/sh 

# where is the project eggX
export OROOT="$HOME/eggX"

SCRIPT_DIR=$OROOT/scripts
OREPO=$OROOT/repo/.

# eggX working path default before read general conf.egg
ROOT="$HOME/ebuild"
LOGFILE="$ROOT/log_$(date +%d-%m-%y).txt"
REPO="$ROOT/repo"
SOURCES="$ROOT/sources"
IMAGES="$ROOT/images"
REPOBACKUP="$ROOT/backup"
BUILD="$ROOT/build"
EDITOR="vim"
CPATH=""
C_INCLUDE_PATH=""
CPLUS_INCLUDE_PATH=""

# include io functions
source "$SCRIPT_DIR/functions.sh"



declare -A MAP    

declare -A BSEQ    
declare -A SORTREQ

ALL_PACKETS=$(ls $OROOT/repo  | sed 's/conf.egg//g')

declare -i MAX_STEP=0


function forcestop(){
	error_c "User Interrupt" " warning work not complete! "
}

trap "forcestop" SIGHUP SIGINT SIGTERM

# test if exist project <name> from packets list...
# $1 packet name
function check_project(){
local tmp=""
if [[ -n "${MAP[$1]}" ]]; then
	return 1
fi
return 0
}


#$1 project
#$2 build phase number 0,1,2.....
function insert_packet(){
local PRI=""
local NAME=""
local INDEX=""
local NUM=0
check_project $1
if [ $? -eq 1 ]; then
	if [ -f $REPO/$1/conf.egg ]; then
		dolog "Read conf.egg from project $1 : action CONFIGURE"	
		xml_count $1 "/egg/project/build"
		NUM=$?
		if [ $NUM -eq 1 ]; then
			xml_count $1 "/egg/project/build/step[@id=\"$2\"]"
			NUM=$?
			if [ $NUM -ne 0 ]; then
				PRI=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/priority")		
				equs "$PRI"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  build priority Phase $2" "project : $1"
				fi
				NAME=$(xml_value $1 "/egg/project/build/step[@id=\"$2\"]/name")		
				equs "$NAME"  
				if [ $? -eq 1 ]; then 
					error_c "Missing  build name Phase $2" "project : $1"
				fi 
				INDEX="$PRI%$1%$NAME"
				BSEQ[$INDEX]="$INDEX"	
			fi	
		fi
	else
		error_c "Missing conf.egg file " "project : $1"
	fi
else
	error_c "Missing project in $REPO " "project : $1"
fi
}

#$1 ID BUILD STEP
function prepare_seq_priority(){
local V=""
unset BSEQ
declare -A BSEQ
declare -i ID=$1
for V in $ALL_PACKETS; do
	insert_packet $V $ID 
done	
SORTREQ=$(echo ${BSEQ[*]}| tr " " "\n" | sort -n )
}

#set numero massimo di step a disposizone
function get_max_step(){
declare -i NUM=0
declare -i MAX=0
for V in $ALL_PACKETS; do
	xml_count $V "/egg/project/build/step"
	NUM=$?
	if [ $MAX  -lt $NUM ]; then 
		MAX=$NUM
	fi
done
MAX_STEP=$MAX
}

# $1 project
# $2 string array prj names
function check_prj_name(){
local NAME=""
local TT=""
local PRJ_NAME=$2
declare -i IND=0
	xml_count $1 "/egg/project/build"
	IND=$?
	if [ $IND -eq 1 ]; then
		IND=0
		while [  $IND -lt $MAX_STEP ]; do
		NAME=$(xml_value $1 "/egg/project/build/step[@id='$IND']/name")		
		equs "$NAME"  
		if [ $? -eq 1 ]; then 
			error_c "Missing  build name Phase $2" "project : $1"
		else
			TT=$(echo $PRJ_NAME | grep $NAME)
			if [ "$TT" == "" ]; then 
				PRJ_NAME="$PRJ_NAME""  ""$NAME"
			fi
		fi 	
		IND=$((IND+1))		
		done
	fi
echo $PRJ_NAME
}


#print build start 
#$1 pririty
#$2 name
#$3 project
function print_build_msg(){
print_ita  "BUILD : $1"  "$2"  "$3"
}

#print build start 
#$1 pririty
#$2 name
#$3 project
function print_clean_msg(){
print_ita  "CLEAN : $1"  "$2"  "$3"
}

#print build start 
#$1 pririty
#$2 name
#$3 project
function print_deploy_msg(){
print_ita  "DEPLOY: $1"  "$2"  "$3"
}

#none
function build_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_build_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/bootstrap.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			"$BUILD/$PRJ/$NAME/build.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			sync
		else
		print_ita "$ID  .." ".." ".."	
		fi	
	done
	ID=$((ID+1))
done
}

#none
function compile_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	echo "--> $SORTREQ"
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_build_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/build.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			sync
		fi
	done
	ID=$((ID+1))
done
}

#none
function clean_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			print_clean_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/clean.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			sync
		fi
	done
	ID=$((ID+1))
done
}


#none
function deploy_all(){
local ID=0 
local V=""
local PRI=""
local NAME=""
local PRJ=""
while [ $ID -lt $MAX_STEP ] ; do
	prepare_seq_priority $ID
	for V in $SORTREQ; do
		V=$(echo $V  | sed -e 's/%/   /g')
		PRI=$(echo $V | awk '{print $1}')
		NAME=$(echo $V | awk '{print $2}')"_$ID"
		PRJ=$(echo $V | awk '{print $3}')
		print_deploy_msg "$PRI" "$NAME" "$PRJ"
		if [ -d "$BUILD/$PRJ/$NAME" ]; then
			cd "$BUILD/$PRJ/$NAME"
			"$BUILD/$PRJ/$NAME/deploy.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			sync
		fi
	done
	ID=$((ID+1))
done
}

#$@ from argv build.sh
function build_single(){
#trovo nomi build per ogni progetto
local ID=0
local PRJ_NAMES=""
local PRI=""
local NAME=""
local PRJ=""
local SEQ=""
isNumber $1
if [ $? -ne 0 ]; then
   error_c "$1 : Input step isn't a number !!"
fi
if [ ! "$2" ]; then
	error_c "Input missing project  !!"
fi
shift
for V in $@; do
	PRJ_NAMES=$(check_prj_name "$V" "$PRJ_NAMES")
done
local PWD=$(pwd)
prepare_seq_priority $NUM
for V in $PRJ_NAMES; do
	for I in $@; do
		for T in $SORTREQ; do
			SEQ=$(echo $T | grep $V | grep $I )
				if [ "$SEQ" != "" ]; then 
					break;
				fi
		done
		SEQ=$(echo $SEQ  | sed -e 's/%/   /g')
		PRI=$(echo $SEQ | awk '{print $1}')
		NAME=$(echo $SEQ | awk '{print $2}')"_$1"
		PRJ=$(echo $SEQ | awk '{print $3}')
		if [ -d "$BUILD/$V/$NAME" ]; then
			print_build_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$V/$NAME"
			"$BUILD/$V/$NAME/clean.sh"
			"$BUILD/$V/$NAME/bootstrap.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			"$BUILD/$V/$NAME/build.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			sync
		fi
	done 
done
}

#$@ from argv build.sh
function compile_single(){
#trovo nomi build per ogni progetto
local ID=0
local PRJ_NAMES=""
local PRI=""
local NAME=""
local PRJ=""
local SEQ=""
isNumber $1
if [ $? -ne 0 ] ; then
   error_c "$1 : Input step isn't a number !!"
fi
if [ ! "$2" ]; then
	error_c "Input missing project  !!"
fi
shift
for V in $@; do
	PRJ_NAMES=$(check_prj_name "$V" "$PRJ_NAMES")
done
local PWD=$(pwd)
prepare_seq_priority $NUM
for V in $PRJ_NAMES; do
	for I in $@; do
		for T in $SORTREQ; do
			SEQ=$(echo $T | grep $V | grep $I )
				if [ "$SEQ" != "" ]; then 
					break;
				fi
		done
		SEQ=$(echo $SEQ  | sed -e 's/%/   /g')
		PRI=$(echo $SEQ | awk '{print $1}')
		NAME=$(echo $SEQ | awk '{print $2}')"_$1"
		PRJ=$(echo $SEQ | awk '{print $3}')
		if [ -d "$BUILD/$V/$NAME" ]; then
			print_build_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$V/$NAME"
			"$BUILD/$V/$NAME/build.sh"
			if [ $? -ne 0 ] ; then
				exit -1;
			fi
			sync
		fi
	done 
done
}


#$@ from argv build.sh
# 0 gcc linux input step + project/s
function clean_single(){
#trovo nomi build per ogni progetto
local ID=0
local PRJ_NAMES=""
local PRI=""
local NAME=""
local PRJ=""
local SEQ=""
isNumber $1
if [ $? -ne 0 ]; then
   error_c "$1 : Input step isn't a number !!"
fi
if [ ! "$2" ]; then
	error_c "Input missing project  !!"
fi
shift
for V in $@; do
	PRJ_NAMES=$(check_prj_name "$V" "$PRJ_NAMES")
done
local PWD=$(pwd)
prepare_seq_priority $NUM
for V in $PRJ_NAMES; do
	for I in $@; do
		for T in $SORTREQ; do
			SEQ=$(echo $T | grep $V | grep $I )
				if [ "$SEQ" != "" ]; then 
					break;
				fi
		done
		SEQ=$(echo $SEQ  | sed -e 's/%/   /g')
		PRI=$(echo $SEQ | awk '{print $1}')
		NAME=$(echo $SEQ | awk '{print $2}')"_$1"
		PRJ=$(echo $SEQ | awk '{print $3}')
		if [ -d "$BUILD/$V/$NAME" ]; then		
			print_clean_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$V/$NAME"
			"$BUILD/$V/$NAME/clean.sh"
			sync
		fi
	done 
done
}

#$@ from argv build.sh
# 0 gcc linux input step + project/s
function deploy_single(){
#trovo nomi build per ogni progetto
local ID=0
local PRJ_NAMES=""
local PRI=""
local NAME=""
local PRJ=""
local SEQ=""
isNumber $1
if [ $? -ne 0 ]; then
   error_c "$1 : Input step isn't a number !!"
fi
if [ ! "$2" ]; then
	error_c "Input missing project  !!"
fi
shift
for V in $@; do
	PRJ_NAMES=$(check_prj_name "$V" "$PRJ_NAMES")
done
local PWD=$(pwd)
prepare_seq_priority $NUM
for V in $PRJ_NAMES; do
	for I in $@; do
		for T in $SORTREQ; do
			SEQ=$(echo $T | grep $V | grep $I )
				if [ "$SEQ" != "" ]; then 
					break;
				fi
		done
		SEQ=$(echo $SEQ  | sed -e 's/%/   /g')
		PRI=$(echo $SEQ | awk '{print $1}')
		NAME=$(echo $SEQ | awk '{print $2}')"_$1"
		PRJ=$(echo $SEQ | awk '{print $3}')
		if [ -d "$BUILD/$V/$NAME" ]; then				
			print_deploy_msg "$PRI" "$NAME" "$PRJ"
			cd "$BUILD/$V/$NAME"
			"$BUILD/$V/$NAME/deploy.sh"
			sync
		fi
	done 
done
}

#$@
function build_all_packet(){
if [ "$1" == "" ]; then
	build_all
else
	build_single $@
fi
sync
print_del_ita
}

#$@
function compile_all_packet(){
if [ "$1" == "" ]; then
	compile_all
else
	compile_single $@
fi
sync
print_del_ita
}

#$@
function clean_all_packet(){
if [ "$1" == "" ]; then
	clean_all
else
	clean_single $@
fi
sync
print_del_ita
}


#$@
function deploy_all_packet(){
if [ "$1" == "" ]; then
	deploy_all
else
	deploy_single $@
fi
sync
print_del_ita
}

#$ARGV TODO
function config_all_step(){
declare -i NUM=0
isNumber $1
if [ $? -ne 0 ]; then
	while [ $NUM -lt $MAX_STEP ]; do 
		$SCRIPT_DIR/configure.sh  $NUM $@
		if [ $? -ne 0 ]; then 
			exit 1
		fi
		NUM=$((NUM+1))
	done
else
	NUM=$1
	shift
	$SCRIPT_DIR/configure.sh $NUM $@
	if [ $? -ne 0 ]; then 
		exit 1
	fi
fi
sync
print_del_ita
}



#$ARGV 
# ex 0 gcc -> try step of project gcc
function try_packet(){
local PRJ=""
local V=""
local NUM=$1
isNumber $1
if [ $? -ne 0 ]; then
   error_c "$1 : Input step isn't a number !!"
fi
if [ ! "$2" ]; then
	error_c "Input missing project  !!"
fi
if [ $NUM -lt $MAX_STEP ]; then
	prepare_seq_priority $NUM
	for i in $SORTREQ; do
		V=$(echo $i  | sed -e 's/%/   /g')
		NAME=$( echo $V | awk '{print $2}' )
		if [ "$NAME" == "$2" ]; then			
			PRJ=$( echo $V | awk '{print $3}' )
			break;
		fi
	done
	V=$(pwd)
	cd "$BUILD/$PRJ/$2_$1"
	bash --init-file $BUILD/$PRJ/$2_$1/setenv.sh
	cd $V	
else
	error_c "Input step too BIG !!"
fi
}

#recussive edit on repo project
function edit_repo_files(){
local ALL_FILES=$(ls "$OREPO")
local VV=""
#cp "$OREPO/conf.egg" "$OREPO/conf.egg_$(date +%d-%m-%y_%H:%M:%S).backup"
$EDITOR "$OREPO/conf.egg"
for VV in $ALL_FILES;  do
if [ "$VV" == "." ]; then continue; fi
if [ "$VV" == ".." ]; then continue; fi
if [ -d "$OREPO/$VV" ]; then 
	cp "$OREPO/$VV/conf.egg" "$OREPO/$VV/conf.egg_$(date +%d-%m-%y_%H:%M:%S).backup"
	$EDITOR "$OREPO/$VV/conf.egg" 
fi
done
}


#$ARGV 
#  gcc -> edit conf.egg of project gcc
function edit_packet(){
local PRJ=""
local V=""
if [ ! "$1" ]; then
	error_c "Missing Input project "
fi
check_project "$1"
if [ $? -ne 0 ]; then
	$EDITOR "$OREPO/$1/conf.egg" > /dev/null  &
else
		if [ "$1" == "self" ]; then
				$EDITOR "eggx" > /dev/null  &
		else
			case $1 in
				self.conf)
				$EDITOR "$OREPO/conf.egg" > /dev/null  &
				;;
				self.configure)
				$EDITOR "$SCRIPT_DIR/configure.sh" > /dev/null  &
				;;
				self.source)
				$EDITOR "$SCRIPT_DIR/sources.sh" > /dev/null  &
				;;
				self.functions)
				$EDITOR "$SCRIPT_DIR/functions.sh"  > /dev/null  &
				;;
				self.repo)
				edit_repo_files
				;;
				*)
				error_c "Missing project in $OREPO " "project : $1"
				;;
			esac	
		fi
fi
}

function show_info(){
print_ita "author" "Angelo" "Coppi"
print_ita "email" "angelogkcop@" "hotmail.com"
print_ita "git" "https://github.com" "ataima"
exit 0
}

function usage(){
	print_c "$BLUE_LIGHT" "usage : ./build.sh <-D> command  <args to pass subcommand>"
	print_c  "$YELLOW" "OPTIONS" "$GREEN" "-D or --debug : set debug mode" 
	print_c  "$YELLOW" "COMMAND" "$GREEN" "source : download all sources from repo projects"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "configure : configure all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "do : configure+build    all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "build :   build all repo projects or specified projects in argv"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "redoall : clear all build and deploy aout and redo source + configure+do"
	print_c  "$YELLOW" "COMMAND" "$GREEN" "shell <step xx> <project nn>: open a shell with setenv for step xx of project nn"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "clean <option step xx> <option project nn>: clean all, clean all step, clean all step:project"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "deploy <option step xx> <option project nn>: clean all, deploy all step, deploy all step:project"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "edit <project nn>: edit a conf.egg file of project nn"	
	print_c  "$YELLOW" "COMMAND" "$GREEN" "info : show program info..."
	exit 1
}


function default_do(){
        build_all_packet
}


#$1 build id number
function main(){
local SOURCE=0
local CONFIGURE=0
local MAKE=0
local DO=0
local REDOALL=0
local TRY=0
local VIM=0
local TRY=0
local INFO=0
local CLEAN=0
local DEPLOY=0

if [ $# -ne 0 ]; then
for i in $@; do
case $i in 
	-D|--debug)
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
	set -x
	dolog "Set Debug ON"
	shift
	;;	
	source)
	SOURCE=1
	shift
	break
	;;
	shell)
	TRY=1
	shift
	break
	;;	
	configure)
	CONFIGURE=1
	shift
	break
	;;	
	edit)
	VIM=1
	shift
	break
	;;	
	build)
	MAKE=1
	shift
	break
	;;	
	clean)
	CLEAN=1
	shift
	break
	;;	
	deploy)
	DEPLOY=1
	shift
	break
	;;	
	do)
	DO=1		
	shift
	break
	;;		
	redoall)
	REDOALL=1		
	shift
	break
	;;	
	info)
	INFO=1		
	break
	;;	
	*)
	usage
	error_c "Command line" " unknow option $i"
	;;
esac
done

fi

if [ $INFO -eq 1 ]; then 
	show_info
fi

#set log to download
if [ ! -d $ROOT ]; then 
	mkdir -p $ROOT
fi

if ! [ -e $LOGFILE ]; then
	touch "$LOGFILE"
fi


if [ $(wc -c < "$LOGFILE" ) -gt 1000000 ]; then 
	VV=$(wc -l < "$LOGFILE")
	VV=$((VV-VV/3))
	sed -i '1,$VVd' "$LOGFILE" >> "$LOGFILE_temp"
	mv "$LOGFILE_temp" "$LOGFILE"
fi
#sort project in repo to bin search
for key in $ALL_PACKETS; do MAP[$key]="$key"; done  
# sync repo file to build path 
dolog "Force resync work repo"
rsync -ry $OREPO $REPO
if [ $? -ne 0 ]; then
	error_c "Cannot  sync work repository"
fi


get_max_step

if [ $REDOALL -ne 0 ]; then 
	$SCRIPT_DIR/sources.sh
	if [ $? -ne 0 ]; then 
		exit 1
	fi
	config_all_step
	build_all_packet
else
	if [ $SOURCE -ne 0 ]; then	
		$SCRIPT_DIR/sources.sh "$@"
	else
		if [ $CONFIGURE -ne 0 ]; then	
			config_all_step "$@"
		else
			if [ $DO -ne 0 ]; then	
				build_all_packet  "$@"
			else
				if [ $MAKE -ne 0 ]; then	
					compile_all_packet  "$@"
				else
					if [ $TRY -ne 0 ]; then	
						try_packet  "$@"
					else
						if [ $VIM -ne 0 ]; then	
							edit_packet  "$@"
						else
							if [ $CLEAN -ne 0 ]; then	
								clean_all_packet "$@"
							else
								if [ $DEPLOY -ne 0 ]; then	
									deploy_all_packet "$@"
								else
									default_do
								fi								
							fi
						fi
					fi
				fi
			fi
		fi
	fi
fi
}

xml_get_env 
main "$@"
